z: mz,
                oldx: mx, oldy: my, oldz: mz,
                pinned: false
              });
              centers[y][x] = clothPoints.length - 1;
            }
          }
        }
        
        createConstraints(createDetailedMesh);
      }

      function computeQuadArea(A, B, C, D) {
        try {
          let area1 = triArea(A, B, C);
          let area2 = triArea(B, C, D);
          return area1 + area2;
        } catch (error) {
          console.error("Error computing quad area:", error);
          return 1.0; // Return a default value to prevent further errors
        }
      }
      
      function triArea(p1, p2, p3) {
        try {
          let ux = p2.x - p1.x;
          let uy = p2.y - p1.y;
          let uz = p2.z - p1.z;
          let vx = p3.x - p1.x;
          let vy = p3.y - p1.y;
          let vz = p3.z - p1.z;
          let cx = uy * vz - uz * vy;
          let cy = uz * vx - ux * vz;
          let cz = ux * vy - uy * vx;
          return 0.5 * Math.sqrt(cx*cx + cy*cy + cz*cz);
        } catch (error) {
          console.error("Error computing triangle area:", error);
          return 0.5; // Return a default value to prevent further errors
        }
      }

      function createConstraints(createDetailedMesh) {
        try {
          // Structural
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (!isValidGridPoint(y, x)) continue;
              
              let idx = grid[y][x];
              
              if (x < cols - 1 && isValidGridPoint(y, x+1)) {
                addConstraint(idx, grid[y][x+1],
                  spacing * (stretchOn ? stretchFactor : BASE_STRETCH),
                  STRUCTURAL
                );
              }
              
              if (y < rows - 1 && isValidGridPoint(y+1, x)) {
                addConstraint(idx, grid[y+1][x],
                  spacing * (stretchOn ? stretchFactor : BASE_STRETCH),
                  STRUCTURAL
                );
              }
            }
          }
          
          // Bending - reduce density for low quality
          const bendingStep = simulationQuality === "low" ? 2 : 1;
          for (let y = 0; y < rows; y += bendingStep) {
            for (let x = 0; x < cols - 2; x += bendingStep) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+2)) continue;
              
              addConstraint(grid[y][x], grid[y][x+2],
                spacing * 2 * (bendingOn ? bendingFactor : BASE_BENDING),
                BENDING
              );
            }
          }
          
          for (let y = 0; y < rows - 2; y += bendingStep) {
            for (let x = 0; x < cols; x += bendingStep) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y+2, x)) continue;
              
              addConstraint(grid[y][x], grid[y+2][x],
                spacing * 2 * (bendingOn ? bendingFactor : BASE_BENDING),
                BENDING
              );
            }
          }
          
          // Shear
          for (let y = 0; y < rows - 1; y++) {
            for (let x = 0; x < cols - 1; x++) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              addConstraint(idxA, idxD,
                Math.sqrt(2) * spacing * (shearOn ? shearFactor : BASE_SHEAR),
                SHEAR
              );
              
              addConstraint(idxB, idxC,
                Math.sqrt(2) * spacing * (shearOn ? shearFactor : BASE_SHEAR),
                SHEAR
              );
            }
          }
          
          // Add detailed constraints only for high/medium quality
          if (createDetailedMesh && simulationQuality !== "low") {
            // Skip this in low quality
            for (let y = 0; y < rows - 1; y++) {
              for (let x = 0; x < cols - 1; x++) {
                if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                    !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
                
                if (!horizontal[y] || !horizontal[y][x] || 
                    !horizontal[y+1] || !horizontal[y+1][x] ||
                    !vertical[y] || !vertical[y][x] || 
                    !vertical[y][x+1] || !centers[y] || !centers[y][x]) continue;
                
                let A = grid[y][x];
                let B = grid[y][x+1];
                let C = grid[y+1][x];
                let D = grid[y+1][x+1];
                let E = horizontal[y][x];
                let F = horizontal[y+1][x];
                let G = vertical[y][x];
                let H = vertical[y][x+1];
                let I = centers[y][x];
                
                addTriConstraints(A, E, I);
                addTriConstraints(A, G, I);
                addTriConstraints(B, E, I);
                addTriConstraints(B, H, I);
                addTriConstraints(C, G, I);
                addTriConstraints(C, F, I);
                addTriConstraints(D, H, I);
                addTriConstraints(D, F, I);
              }
            }
          }
        } catch (error) {
          console.error("Error creating constraints:", error);
          showError("Error creating cloth constraints. Please try a lower resolution or quality setting.");
        }
      }

      function addTriConstraints(i1, i2, i3) {
        try {
          if (!clothPoints[i1] || !clothPoints[i2] || !clothPoints[i3]) return;
          
          let dist1 = distBetween(i1, i2);
          let dist2 = distBetween(i2, i3);
          let dist3 = distBetween(i3, i1);
          
          if (dist1 <= 0 || dist2 <= 0 || dist3 <= 0) return;
          
          addConstraint(i1, i2, dist1, STRUCTURAL);
          addConstraint(i2, i3, dist2, STRUCTURAL);
          addConstraint(i3, i1, dist3, STRUCTURAL);
        } catch (error) {
          console.error("Error adding triangle constraints:", error);
        }
      }

      function addConstraint(i, j, len, type) {
        try {
          if (i === undefined || j === undefined || i === j || len <= 0) return;
          
          let a = Math.min(i, j);
          let b = Math.max(i, j);
          
          // Check if constraint already exists
          for (let c of clothConstraints) {
            if (c.p1 === a && c.p2 === b) return;
          }
          
          clothConstraints.push({ p1: a, p2: b, length: len, type });
        } catch (error) {
          console.error("Error adding constraint:", error);
        }
      }

      function distBetween(i1, i2) {
        try {
          let p1 = clothPoints[i1];
          let p2 = clothPoints[i2];
          
          if (!p1 || !p2) {
            console.error("Invalid indices for distBetween:", i1, i2);
            return spacing; // Return default spacing as fallback
          }
          
          let dx = p2.x - p1.x;
          let dy = p2.y - p1.y;
          let dz = p2.z - p1.z;
          return Math.sqrt(dx*dx + dy*dy + dz*dz);
        } catch (error) {
          console.error("Error calculating distance:", error);
          return spacing; // Return a default value
        }
      }

      function updateCloth() {
        try {
          let freq = 0.01;
          
          // Skip some points in low quality mode
          const step = simulationQuality === "low" ? 2 : 1;
          
          // Process points - apply forces and integration
          for (let i = 0; i < clothPoints.length; i += step) {
            let p = clothPoints[i];
            if (!p || p.pinned) continue;
            
            let vx = (p.x - p.oldx) * (dampingOn ? damping : BASE_DAMPING);
            let vy = (p.y - p.oldy) * (dampingOn ? damping : BASE_DAMPING);
            let vz = (p.z - p.oldz) * (dampingOn ? damping : BASE_DAMPING);
            p.oldx = p.x;
            p.oldy = p.y;
            p.oldz = p.z;

            // Precompute wind effect based on frame
            let sinVal = Math.sin(frameCount * freq);
            let effectiveWindX = windXOn ? windBuffer * windX * sinVal : BASE_WINDX;
            let effectiveWindY = windYOn ? windBuffer * windY * sinVal : BASE_WINDY;
            let effectiveWindZ = windZOn ? windBuffer * windZ * sinVal : BASE_WINDZ;

            let effGrav = gravityOn ? gravity : BASE_GRAVITY;
            let effWeight = weightOn ? weight : BASE_WEIGHT;

            p.x += vx + effectiveWindX;
            p.y += vy + effGrav * effWeight + effectiveWindY;
            p.z += vz + effectiveWindZ;
          }

          // Apply constraints with different iteration counts based on quality
          let effIter = iterationsOn ? iterations : BASE_ITERATIONS;
          // For low quality, reduce iterations
          if (simulationQuality === "low") effIter = Math.max(1, Math.floor(effIter / 2));
          
          // Fast constraint solver that processes constraints in batches
          for (let iter = 0; iter < effIter; iter++) {
            // Process constraints in smaller chunks for better performance
            // and to avoid blocking the UI thread for too long
            const batchSize = 500; // Process 500 constraints at a time
            
            for (let batchStart = 0; batchStart < clothConstraints.length; batchStart += batchSize) {
              const batchEnd = Math.min(batchStart + batchSize, clothConstraints.length);
              
              for (let j = batchStart; j < batchEnd; j++) {
                if (j >= clothConstraints.length) continue;
                
                let c = clothConstraints[j];
                if (!c) continue;
                
                let p1 = clothPoints[c.p1];
                let p2 = clothPoints[c.p2];
                
                if (!p1 || !p2) continue;
                
                // Skip if both points are pinned (no need to calculate)
                if (p1.pinned && p2.pinned) continue;
                
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                let dz = p2.z - p1.z;
                let distSq = dx*dx + dy*dy + dz*dz;
                
                // Early skip if points are at almost exactly the right distance
                const epsilon = 0.000001;
                const targetDistSq = c.length * c.length;
                if (Math.abs(distSq - targetDistSq) < epsilon) continue;
                
                let distVal = Math.sqrt(distSq);
                
                // Avoid division by zero
                if (distVal > 0.0001) {
                  let diff = (distVal - c.length) / distVal;
                  
                  // Apply constraint based on whether points are pinned
                  if (!p1.pinned && !p2.pinned) {
                    p1.x += dx * 0.5 * diff;
                    p1.y += dy * 0.5 * diff;
                    p1.z += dz * 0.5 * diff;
                    
                    p2.x -= dx * 0.5 * diff;
                    p2.y -= dy * 0.5 * diff;
                    p2.z -= dz * 0.5 * diff;
                  } else if (!p1.pinned) {
                    p1.x += dx * diff;
                    p1.y += dy * diff;
                    p1.z += dz * diff;
                  } else if (!p2.pinned) {
                    p2.x -= dx * diff;
                    p2.y -= dy * diff;
                    p2.z -= dz * diff;
                  }
                }
              }
            }
          }

          // Handle collisions (optimized)
          if (simulationQuality !== "low") {
            doSelfCollision();
          }
          
          if (simulationMode === "draped") {
            if (formMode === "sphere") {
              doSphereCollision();
            } else if (formMode === "cylinder") {
              doCylinderCollision();
            }
            doFloorCollision();
          }
        } catch (error) {
          console.error("Error in cloth simulation:", error);
        }
      }

      function doSelfCollision() {
        try {
          // Skip self-collision for low quality mode
          if (simulationQuality === "low") return;
          
          const threshold = spacing * 0.5;
          const gridSize = threshold * 2;
          const grid = new Map();
          
          // Add points to spatial grid
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid points
            if (!p) continue;
            
            // Calculate grid cell coordinates
            const gx = Math.floor(p.x / gridSize);
            const gy = Math.floor(p.y / gridSize);
            const gz = Math.floor(p.z / gridSize);
            const key = `${gx},${gy},${gz}`;
            
            // Add point to grid
            if (!grid.has(key)) {
              grid.set(key, []);
            }
            grid.get(key).push(i);
          }
          
          // Check nearby cells for collisions
          for (let i = 0; i < clothPoints.length; i++) {
            let p1 = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p1 || p1.pinned) continue;
            
            const gx = Math.floor(p1.x / gridSize);
            const gy = Math.floor(p1.y / gridSize);
            const gz = Math.floor(p1.z / gridSize);
            
            // Check current and neighboring cells
            for (let dx = -1; dx <= 1; dx++) {
              for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                  const key = `${gx+dx},${gy+dy},${gz+dz}`;
                  const cell = grid.get(key);
                  
                  if (!cell) continue;
                  
                  // Check against points in cell
                  for (let j of cell) {
                    // Skip self or already processed pairs
                    if (j <= i) continue;
                    
                    let p2 = clothPoints[j];
                    
                    // Skip invalid or pinned points
                    if (!p2 || p2.pinned) continue;
                    
                    let dx = p2.x - p1.x;
                    let dy = p2.y - p1.y;
                    let dz = p2.z - p1.z;
                    let d = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (d < threshold && d > 0.0001) { // Avoid very small distances
                      let overlap = threshold - d;
                      let nx = dx / d;
                      let ny = dy / d;
                      let nz = dz / d;
                      
                      p1.x -= nx * overlap * 0.5;
                      p1.y -= ny * overlap * 0.5;
                      p1.z -= nz * overlap * 0.5;
                      p2.x += nx * overlap * 0.5;
                      p2.y += ny * overlap * 0.5;
                      p2.z += nz * overlap * 0.5;
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error("Error in self-collision:", error);
        }
      }

      // Fixed sphere collision function
      function doSphereCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            let dx = p.x - sphereCentre.x;
            let dy = p.y - sphereCentre.y;
            let dz = p.z - sphereCentre.z;
            let distSq = dx*dx + dy*dy + dz*dz;
            let radiusSq = sphereRadius * sphereRadius;
            
            // Early optimization - check squared distance first
            if (distSq >= radiusSq) continue;
            
            let distVal = Math.sqrt(distSq);
            
            // Avoid division by zero
            if (distVal < 0.0001) {
              // Point is very close to center, push it out in a random direction
              let angle = Math.random() * Math.PI * 2;
              dx = Math.cos(angle);
              dy = Math.sin(angle);
              dz = Math.random() - 0.5;
              
              // Normalize
              let len = Math.sqrt(dx*dx + dy*dy + dz*dz);
              dx /= len;
              dy /= len;
              dz /= len;
              
              distVal = 0.0001;
            }
            
            let overlap = sphereRadius - distVal;
            let nx = dx / distVal;
            let ny = dy / distVal;
            let nz = dz / distVal;
            
            // Push point to surface of sphere
            p.x += nx * overlap * (1 + 0.01); // Add small buffer to prevent flicker
            p.y += ny * overlap * (1 + 0.01);
            p.z += nz * overlap * (1 + 0.01);
            
            // Apply friction to reduce sliding
            p.oldx = p.x - collisionFriction * (p.x - p.oldx);
            p.oldy = p.y - collisionFriction * (p.y - p.oldy);
            p.oldz = p.z - collisionFriction * (p.z - p.oldz);
          }
        } catch (error) {
          console.error("Error in sphere collision:", error);
        }
      }

      // Fixed cylinder collision function
      function doCylinderCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            // Only check points that are within the cylinder's height range
            if (p.y > cylinderTopY && p.y < cylinderBottomY) {
              // Calculate distance to cylinder axis (which is along Y)
              let dx = p.x;
              let dz = p.z;
              let r = Math.sqrt(dx*dx + dz*dz);
              
              if (r < cylRadius) {
                let overlap = cylRadius - r;
                
                // Avoid division by zero
                if (r < 0.0001) {
                  // Point is very close to axis, push it out in a random XZ direction
                  let angle = Math.random() * Math.PI * 2;
                  dx = Math.cos(angle);
                  dz = Math.sin(angle);
                  r = 0.0001;
                } else {
                  dx /= r;
                  dz /= r;
                }
                
                // Push point to surface of cylinder
                p.x += dx * overlap * (1 + 0.01); // Add small buffer to prevent flicker
                p.z += dz * overlap * (1 + 0.01);
                
                // Apply friction to reduce sliding
                p.oldx = p.x - collisionFriction * (p.x - p.oldx);
                p.oldz = p.z - collisionFriction * (p.z - p.oldz);
              }
            }
            
            // Also check cylinder caps (top and bottom circles)
            if (p.y < cylinderTopY && p.y > cylinderTopY - cylRadius) {
              // Distance to top cap center
              let dx = p.x;
              let dy = p.y - cylinderTopY;
              let dz = p.z;
              let dxz = Math.sqrt(dx*dx + dz*dz);
              
              // If inside the top cap and below the sphere created by the cap edge
              if (dxz < cylRadius) {
                let capY = cylinderTopY;
                
                // Check if point is inside the cap's spherical region
                let distToEdge = Math.sqrt(Math.pow(cylRadius - dxz, 2) + dy*dy);
                if (distToEdge < cylRadius) {
                  // Push point to cap surface
                  p.y = cylinderTopY;
                  p.oldy = p.y - collisionFriction * (p.y - p.oldy);
                }
              }
            }
            
            // Check bottom cap similarly
            if (p.y > cylinderBottomY && p.y < cylinderBottomY + cylRadius) {
              let dx = p.x;
              let dy = p.y - cylinderBottomY;
              let dz = p.z;
              let dxz = Math.sqrt(dx*dx + dz*dz);
              
              if (dxz < cylRadius) {
                let capY = cylinderBottomY;
                
                let distToEdge = Math.sqrt(Math.pow(cylRadius - dxz, 2) + dy*dy);
                if (distToEdge < cylRadius) {
                  p.y = cylinderBottomY;
                  p.oldy = p.y - collisionFriction * (p.y - p.oldy);
                }
              }
            }
          }
        } catch (error) {
          console.error("Error in cylinder collision:", error);
        }
      }

      // Improved floor collision
      function doFloorCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            if (p.y > floorY) {
              // Store vertical velocity for friction calculation
              let vy = p.y - p.oldy;
              
              // Collide with floor
              p.y = floorY;
              
              // Apply friction scaled by impact velocity
              let friction = Math.min(collisionFriction * (1 + Math.abs(vy) * 2), 0.95);
              
              // Apply horizontal friction based on impact velocity
              p.oldx = p.x - (p.x - p.oldx) * friction;
              p.oldz = p.z - (p.z - p.oldz) * friction;
              
              // Apply slight bounce if velocity was high
              if (vy > 1.0) {
                p.oldy = p.y + vy * -0.2; // 20% bounce
              } else {
                p.oldy = p.y;
              }
            }
          }
        } catch (error) {
          console.error("Error in floor collision:", error);
        }
      }

      /* Improved Touch Event Handlers */
      function setupTouchHandlers() {
        try {
          const canvas = document.getElementById('defaultCanvas0');
          if (!canvas) {
            console.error("Canvas not found for touch setup");
            return;
          }
          
          // Touch start event
          canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length > 0) {
              e.preventDefault(); // Prevent scrolling
              
              // Convert touch coordinates to canvas coordinates
              const canvasRect = canvas.getBoundingClientRect();
              const touchX = e.touches[0].clientX - canvasRect.left;
              const touchY = e.touches[0].clientY - canvasRect.top;
              
              // Update p5.js mouseX and mouseY
              mouseX = touchX;
              mouseY = touchY;
              
              // Call the mousePressed function
              mousePressed();
            }
          }, { passive: false });
          
          // Touch move event
          canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length > 0) {
              e.preventDefault(); // Prevent scrolling when interacting with cloth
              
              // Convert touch coordinates to canvas coordinates
              const canvasRect = canvas.getBoundingClientRect();
              const touchX = e.touches[0].clientX - canvasRect.left;
              const touchY = e.touches[0].clientY - canvasRect.top;
              
              // Update p5.js mouseX and mouseY
              mouseX = touchX;
              mouseY = touchY;
              
              // Call the mouseDragged function
              mouseDragged();
            }
          }, { passive: false });
          
          // Touch end event
          canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            mouseReleased();
          }, { passive: false });
          
          // Touch cancel event
          canvas.addEventListener('touchcancel', function(e) {
            e.preventDefault();
            mouseReleased();
          }, { passive: false });
          
          console.log("Touch handlers initialized successfully");
        } catch (error) {
          console.error("Error setting up touch handlers:", error);
        }
      }

      /* 3D Dragging */
      function mousePressed() {
        try {
          if (interactionMode === "drag") {
            let closest = null;
            let closestDist = 20; // Increased for better mobile/touch interaction
            
            // Find closest point to mouse
            for (let i = 0; i < clothPoints.length; i++) {
              let p = clothPoints[i];
              
              // Skip invalid points
              if (!p) continue;
              
              let sx = modelX(p.x, p.y, p.z);
              let sy = modelY(p.x, p.y, p.z);
              let d = dist(mouseX, mouseY, sx, sy);
              
              if (d < closestDist) {
                closestDist = d;
                closest = i;
              }
            }
            
            if (closest !== null) {
              dragPointIndex = closest;
              dragPlaneZ = clothPoints[closest].z;
            }
          }
        } catch (error) {
          console.error("Error in mouse press handling:", error);
        }
        return false; // Prevent default
      }

      function unproject(mx, my, fixedZ) {
        try {
          let d = (height/2) / tan(PI*30/180);
          let nx = mx - width/2;
          let ny = my - height/2;
          let factor = (d + fixedZ) / d;
          let wx = nx * factor;
          let wy = ny * factor;
          return createVector(wx, wy, fixedZ);
        } catch (error) {
          console.error("Error in unprojection:", error);
          return createVector(0, 0, fixedZ); // Return a default vector
        }
      }

      function mouseDragged() {
        try {
          if (interactionMode === "drag" && dragPointIndex !== null) {
            let p = clothPoints[dragPointIndex];
            
            // Skip invalid points
            if (!p) return false;
            
            let newPos = unproject(mouseX, mouseY, dragPlaneZ);
            p.x = newPos.x;
            p.y = newPos.y;
            p.oldx = newPos.x;
            p.oldy = newPos.y;
          }
        } catch (error) {
          console.error("Error in mouse drag handling:", error);
        }
        return false; // Prevent default
      }

      function mouseReleased() {
        dragPointIndex = null;
        return false; // Prevent default
      }
      
      function windowResized() {
        try {
          // Get current canvas position
          let container = select('#canvasContainer');
          let width = container.width;
          let height = container.height;
          
          // Resize canvas
          resizeCanvas(width, height);
          
          // Reset camera if orientation was reset
          if (doResetOrientation) {
            camera(0, 0, (height/2) / tan(PI*30/180),
                  0, 0, 0,
                  0, 1, 0);
            doResetOrientation = false;
          }
          
          // Handle mobile UI
          if (windowWidth <= 768) {
            select('#uiPanel').removeClass('active');
          }
        } catch (error) {
          console.error("Error in window resize:", error);
        }
      }
      
      /* Tab Navigation */
      function showTab(tabId) {
        try {
          // Hide all tab contents
          document.querySelectorAll('.tabContent').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Deactivate all tabs
          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Show selected tab content
          document.getElementById(tabId).classList.add('active');
          
          // Activate selected tab
          document.querySelector(`[onclick="showTab('${tabId}')"]`).classList.add('active');
        } catch (error) {
          console.error("Error switching tabs:", error);
        }
      }
      
      /* Fabric Presets */
      function applyFabricPreset(presetKey) {
        try {
          if (presetKey === 'custom') {
            select('#fabricDescription').html('Using custom parameter settings.');
            return;
          }
          
          let preset = FABRIC_PRESETS[presetKey];
          if (!preset) return;
          
          // Update description
          select('#fabricDescription').html(preset.properties.description);
          
          // Set parameters based on preset
          setDamping(true, preset.properties.damping);
          setStretch(true, preset.properties.stretch);
          setBending(true, preset.properties.bending);
          setShear(true, preset.properties.shear);
          setWeight(true, preset.properties.weight);
          
          // Update simulation
          setupCloth();
        } catch (error) {
          console.error("Error applying fabric preset:", error);
        }
      }
      
      /* Animation and Time-lapse Features */
      function toggleRecording() {
        try {
          recordingActive = !recordingActive;
          
          if (recordingActive) {
            // Start recording
            select('#recordBtn').html('Stop Recording');
            recordedFrames = [];
            
            // Record initial state
            recordClothState();
          } else {
            // Stop recording
            select('#recordBtn').html('Start Recording');
            select('#playBtn').removeAttribute('disabled');
            
            // Show stats about recording
            const memory = estimateMemoryUsage();
            console.log(`Recording complete. Frames: ${recordedFrames.length}, Estimated memory: ${memory.toFixed(2)} MB`);
          }
        } catch (error) {
          console.error("Error toggling recording:", error);
          showError("Error with recording system. Please try again.");
        }
      }

      function recordClothState() {
        try {
          if (!recordingActive) return;
          
          // Create compressed representation of cloth points
          let frameState = [];
          
          // Sampling frequency - record fewer points for large cloth
          // This is a key optimization to reduce memory usage
          const step = clothPoints.length > 1000 ? 3 : (clothPoints.length > 500 ? 2 : 1);
          
          // For very large cloth, sample key structural points
          const samplingStrategy = (clothPoints.length > 2000) ? "structural" : "uniform";
          
          if (samplingStrategy === "uniform") {
            // Simple uniform sampling
            for (let i = 0; i < clothPoints.length; i += step) {
              let p = clothPoints[i];
              
              if (p) {
                frameState.push({
                  index: i,
                  x: p.x,
                  y: p.y,
                  z: p.z,
                  oldx: p.oldx,
                  oldy: p.oldy,
                  oldz: p.oldz,
                  pinned: p.pinned
                });
              }
            }
          } else {
            // Structural sampling - prioritize grid points over internal details
            for (let y = 0; y < rows; y += step) {
              for (let x = 0; x < cols; x += step) {
                if (isValidGridPoint(y, x)) {
                  const i = grid[y][x];
                  let p = clothPoints[i];
                  
                  if (p) {
                    frameState.push({
                      index: i,
                      x: p.x,
                      y: p.y,
                      z: p.z,
                      oldx: p.oldx,
                      oldy: p.oldy,
                      oldz: p.oldz,
                      pinned: p.pinned
                    });
                  }
                }
              }
            }
          }
          
          recordedFrames.push(frameState);
          
          // Memory management - limit to reasonable number of frames
          // 200 frames = 10 seconds at 20fps
          const maxFrames = 200;
          if (recordedFrames.length > maxFrames) {
            // Remove oldest frame
            recordedFrames.shift();
          }
          
          // Check recording size
          if (recordedFrames.length % 50 === 0) {
            const memory = estimateMemoryUsage();
            if (memory > 50) {
              // Memory usage is too high, increase step size
              step++;
              console.log(`Memory usage high (${memory.toFixed(2)} MB). Reducing recording quality.`);
            }
          }
          
          // Schedule next recording
          setTimeout(recordClothState, 50); // 20 fps
        } catch (error) {
          console.error("Error recording state:", error);
          recordingActive = false;
          select('#recordBtn').html('Start Recording');
          showError("Recording error: " + error.message);
        }
      }

      // Estimate memory usage of recorded frames
      function estimateMemoryUsage() {
        try {
          // Each point record uses approximately 8 bytes per number (6 coordinates + index)
          // Plus object overhead
          const bytesPerPoint = 7 * 8 + 32; // 7 numbers + object overhead
          
          let totalPoints = 0;
          for (let frame of recordedFrames) {
            totalPoints += frame.length;
          }
          
          // Convert to MB
          return (totalPoints * bytesPerPoint) / (1024 * 1024);
        } catch (error) {
          console.error("Error estimating memory usage:", error);
          return 0;
        }
      }

      function togglePlayback() {
        try {
          playbackActive = !playbackActive;
          
          if (playbackActive) {
            // Start playback
            select('#playBtn').html('Stop Playback');
            select('#recordBtn').attribute('disabled', true);
            
            // Disable simulation during playback
            simulationRunning = false;
            select('#playPauseBtn').html('Play Simulation');
            
            // Reset playback position
            playbackFrame = 0;
            
            // Start playback interval
            playbackInterval = setInterval(() => {
              if (playbackFrame >= recordedFrames.length) {
                playbackFrame = 0;
              }
              
              restoreClothState(recordedFrames[playbackFrame]);
              playbackFrame++;
            }, 50); // 20 fps
            
          } else {
            // Stop playback
            select('#playBtn').html('Play Animation');
            select('#recordBtn').removeAttribute('disabled');
            
            // Clear interval
            clearInterval(playbackInterval);
            playbackInterval = null;
          }
        } catch (error) {
          console.error("Error toggling playback:", error);
          showError("Error with playback system. Please try again.");
        }
      }
      
      // Improved playback with interpolation
      function restoreClothState(frameState) {
        try {
          // Reset all point positions to their last positions first
          // This helps with points that aren't in the sparse recording
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            if (!p || p.pinned) continue;
            
            // Only reset position, not previous position
            // This creates smoother transitions
            p.x = p.oldx;
            p.y = p.oldy;
            p.z = p.oldz;
          }
          
          // Apply recorded points
          for (let i = 0; i < frameState.length; i++) {
            let state = frameState[i];
            let index = state.index;
            
            if (clothPoints[index]) {
              clothPoints[index].x = state.x;
              clothPoints[index].y = state.y;
              clothPoints[index].z = state.z;
              clothPoints[index].oldx = state.oldx;
              clothPoints[index].oldy = state.oldy;
              clothPoints[index].oldz = state.oldz;
              // Don't override pinned status
            }
          }
          
          // Interpolate missing points by running constraint satisfaction
          // This creates a more accurate reconstruction of the full cloth state
          for (let iter = 0; iter < 3; iter++) {
            smoothClothState();
          }
        } catch (error) {
          console.error("Error restoring state:", error);
        }
      }
      
      // Smooth out cloth state by averaging neighboring points (for sparse recordings)
      function smoothClothState() {
        try {
          // Only smooth horizontal/vertical neighbors in grid
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (!isValidGridPoint(y, x)) continue;
              
              let idx = grid[y][x];
              let p = clothPoints[idx];
              
              // Skip invalid or pinned points
              if (!p || p.pinned) continue;
              
              let neighbors = [];
              
              // Check left
              if (x > 0 && isValidGridPoint(y, x-1)) {
                let left = clothPoints[grid[y][x-1]];
                if (left) neighbors.push(left);
              }
              
              // Check right
              if (x < cols - 1 && isValidGridPoint(y, x+1)) {
                let right = clothPoints[grid[y][x+1]];
                if (right) neighbors.push(right);
              }
              
              // Check top
              if (y > 0 && isValidGridPoint(y-1, x)) {
                let top = clothPoints[grid[y-1][x]];
                if (top) neighbors.push(top);
              }
              
              // Check bottom
              if (y < rows - 1 && isValidGridPoint(y+1, x)) {
                let bottom = clothPoints[grid[y+1][x]];
                if (bottom) neighbors.push(bottom);
              }
              
              // Apply average of neighbors
              if (neighbors.length > 0) {
                let avgX = 0, avgY = 0, avgZ = 0;
                let avgOldX = 0, avgOldY = 0, avgOldZ = 0;
                
                for (let n of neighbors) {
                  avgX += n.x;
                  avgY += n.y;
                  avgZ += n.z;
                  avgOldX += n.oldx;
                  avgOldY += n.oldy;
                  avgOldZ += n.oldz;
                }
                
                // Blend with current value (30% neighbors, 70% current)
                let weight = 0.3;
                p.x = p.x * (1 - weight) + (avgX / neighbors.length) * weight;
                p.y = p.y * (1 - weight) + (avgY / neighbors.length) * weight;
                p.z = p.z * (1 - weight) + (avgZ / neighbors.length) * weight;
                p.oldx = p.oldx * (1 - weight) + (avgOldX / neighbors.length) * weight;
                p.oldy = p.oldy * (1 - weight) + (avgOldY / neighbors.length) * weight;
                p.oldz = p.oldz * (1 - weight) + (avgOldZ / neighbors.length) * weight;
              }
            }
          }
        } catch (error) {
          console.error("Error smoothing cloth state:", error);
        }
      }
      
      function createTimelapse() {
        try {
          // Start with a fresh cloth
          setupCloth();
          
          // Disable UI during timelapse
          select('#timelapseBtn').html('Creating Time-lapse...');
          select('#timelapseBtn').attribute('disabled', true);
          select('#recordBtn').attribute('disabled', true);
          select('#playBtn').attribute('disabled', true);
          
          // Make sure simulation is running
          simulationRunning = true;
          
          // Create overlay to display timelapse
          let overlay = createDiv();
          overlay.id('timelapseOverlay');
          overlay.parent('canvasContainer');
          overlay.style('position', 'absolute');
          overlay.style('top', '20px');
          overlay.style('right', '20px');
          overlay.style('background', 'rgba(26, 32, 44, 0.95)');
          overlay.style('padding', '15px');
          overlay.style('border-radius', '8px');
          overlay.style('color', 'white');
          overlay.html('Creating time-lapse: 0%');
          
          // Start timelapse recording
          recordTimelapse(0, 100, overlay);
        } catch (error) {
          console.error("Error creating timelapse:", error);
          showError("Error creating timelapse. Please try again.");
        }
      }
      
      function recordTimelapse(currentStep, totalSteps, overlay) {
        try {
          // Update progress
          let progress = floor((currentStep / totalSteps) * 100);
          overlay.html(`Creating time-lapse: ${progress}%`);
          
          // In a real implementation, would save canvas state
          
          // Move to next step or complete
          if (currentStep < totalSteps) {
            // Update simulation multiple times to advance state
            for (let i = 0; i < 5; i++) {
              updateCloth();
            }
            
            // Schedule next recording after a short delay
            setTimeout(() => {
              recordTimelapse(currentStep + 1, totalSteps, overlay);
            }, 50);
          } else {
            // Complete timelapse
            finishTimelapse(overlay);
          }
        } catch (error) {
          console.error("Error in timelapse recording:", error);
          finishTimelapse(overlay, true);
        }
      }
      
      function finishTimelapse(overlay, error = false) {
        try {
          // In a real implementation, would compile frames into animation
          if (error) {
            overlay.html('Time-lapse failed.<br><button id="dismissBtn">Dismiss</button>');
          } else {
            overlay.html('Time-lapse complete!<br><button id="dismissBtn">Dismiss</button>');
          }
          
          // Add dismiss button action
          select('#dismissBtn').mousePressed(() => {
            overlay.remove();
          });
          
          // Re-enable UI
          select('#timelapseBtn').html('Create Time-lapse');
          select('#timelapseBtn').removeAttribute('disabled');
          select('#recordBtn').removeAttribute('disabled');
          select('#playBtn').removeAttribute('disabled');
        } catch (error) {
          console.error("Error finishing timelapse:", error);
          // Emergency cleanup
          overlay.remove();
          select('#timelapseBtn').html('Create Time-lapse');
          select('#timelapseBtn').removeAttribute('disabled');
          select('#recordBtn').removeAttribute('disabled');
          select('#playBtn').removeAttribute('disabled');
        }
      }
      
      /* Animation presets */
      // Clear any existing animation intervals
      let activeAnimationInterval = null;

      function applyAnimationPreset(preset) {
        try {
          // Stop any existing animation
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
          
          // Reset cloth first
          setupCloth();
          
          // Make sure simulation is running
          simulationRunning = true;
          select('#playPauseBtn').html('Pause Simulation');
          
          // Apply the requested animation preset
          switch (preset) {
            case 'breeze':
              applyBreezePreset();
              break;
            case 'gust':
              applyGustPreset();
              break;
            case 'drop':
              applyDropPreset();
              break;
            case 'material':
              applyMaterialTestPreset();
              break;
            case 'gravity':
              applyGravityPreset();
              break;
            default:
              console.warn("Unknown animation preset:", preset);
          }
          
          // Reset dropdown after a delay
          setTimeout(() => {
            try {
              document.getElementById('animationPresetSelect').value = '';
            } catch (e) {
              console.error("Could not reset animation dropdown:", e);
            }
          }, 500);
        } catch (error) {
          console.error("Error applying animation preset:", error);
          showError("Error applying animation. Please try again.");
          
          // Cleanup any intervals in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyBreezePreset() {
        try {
          // Set up gentle breeze animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.98);
          setGravity(true, 0.3);
          setShadingMode("cloth");
          
          // Start with no wind
          setWind(true, 0, 0, 0);
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 200;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            // Oscillating gentle wind
            let windStrength = 0.1 * Math.sin(step * 0.1);
            setWind(true, windStrength, 0, windStrength * 0.5);
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in breeze preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyGustPreset() {
        try {
          // Set up for wind gust animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.3);
          setShadingMode("cloth");
          
          // Start with no wind
          setWind(true, 0, 0, 0);
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 150;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step > 20 && step < 40) {
              // Build up
              let ramp = map(step, 20, 40, 0, 0.8);
              setWind(true, ramp, 0, ramp * 0.3);
            } else if (step >= 40 && step < 70) {
              // Full gust
              setWind(true, 0.8, 0, 0.24);
            } else if (step >= 70 && step < 90) {
              // Fade out
              let ramp = map(step, 70, 90, 0.8, 0);
              setWind(true, ramp, 0, ramp * 0.3);
            } else {
              // No wind
              setWind(true, 0, 0, 0);
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in gust preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyDropPreset() {
        try {
          // Set up for cloth drop animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(false, 0);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animate after a short delay
          setTimeout(() => {
            // Turn on gravity after a delay
            setGravity(true, 0.4);
          }, 1000);
        } catch (error) {
          console.error("Error in drop preset:", error);
        }
      }

      function applyMaterialTestPreset() {
        try {
          // Set up for material test
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.4);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 170;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step === 10) {
              // Start with stiff material
              setStretch(true, 0.8);
              setBending(true, 1.2);
              showError("Testing stiff material");
            } else if (step === 50) {
              // Change to medium material
              setStretch(true, 1.0);
              setBending(true, 1.0);
              showError("Testing medium material");
            } else if (step === 90) {
              // Change to soft, flexible material
              setStretch(true, 1.2);
              setBending(true, 0.8);
              showError("Testing soft material");
            } else if (step === 130) {
              // Change to very stretchy material
              setStretch(true, 1.5);
              setBending(true, 0.6);
              showError("Testing stretchy material");
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in material test preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyGravityPreset() {
        try {
          // Set up for gravity increase animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.1);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 150;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step % 20 === 0 && step <= 100) {
              // Increase gravity in steps
              let gravityValue = map(step, 0, 100, 0.1, 1.0);
              setGravity(true, gravityValue);
              showError(`Gravity: ${gravityValue.toFixed(2)}`);
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in gravity preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }
      
      /* Parameter setting helper functions */
      function setSimulationMode(mode) {
        try {
          let radio = selectAll('input[name="simulationMode_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              simulationMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting simulation mode:", error);
        }
      }
      
      function setFormMode(mode) {
        try {
          let radio = selectAll('input[name="formMode_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              formMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting form mode:", error);
        }
      }
      
      function setPinningMode(mode) {
        try {
          let radio = selectAll('input[name="pinning_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              pinningMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting pinning mode:", error);
        }
      }
      
      function setShadingMode(mode) {
        try {
          let radio = selectAll('input[name="shading_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              shadingMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting shading mode:", error);
        }
      }
      
      function setDamping(enabled, value) {
        try {
          setRadioParam("dampingRadioGroup_radio", enabled);
          dampingOn = enabled;
          if (enabled) {
            damping = value;
            select("#dampingVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting damping:", error);
        }
      }
      
      function setGravity(enabled, value) {
        try {
          setRadioParam("gravityRadioGroup_radio", enabled);
          gravityOn = enabled;
          if (enabled) {
            gravity = value;
            select("#gravityVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting gravity:", error);
        }
      }
      
      function setWind(enabled, x, y, z) {
        try {
          setRadioParam("windXRadioGroup_radio", enabled);
          setRadioParam("windYRadioGroup_radio", enabled);
          setRadioParam("windZRadioGroup_radio", enabled);
          windXOn = windYOn = windZOn = enabled;
          if (enabled) {
            windX = x;
            windY = y;
            windZ = z;
            select("#windXVal").html(nf(x, 1, 2));
            select("#windYVal").html(nf(y, 1, 2));
            select("#windZVal").html(nf(z, 1, 2));
            // Update sliders if needed
          }
        } catch (error) {
          console.error("Error setting wind:", error);
        }
      }
      
      function setWindBuffer(enabled, value) {
        try {
          setRadioParam("windBufRadioGroup_radio", enabled);
          windBufOn = enabled;
          if (enabled) {
            windBuffer = value;
            select("#windBufVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting wind buffer:", error);
        }
      }
      
      function setStretch(enabled, value) {
        try {
          setRadioParam("stretchRadioGroup_radio", enabled);
          stretchOn = enabled;
          if (enabled) {
            stretchFactor = value;
            select("#stretchVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting stretch:", error);
        }
      }
      
      function setShear(enabled, value) {
        try {
          setRadioParam("shearRadioGroup_radio", enabled);
          shearOn = enabled;
          if (enabled) {
            shearFactor = value;
            select("#shearVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting shear:", error);
        }
      }
      
      function setBending(enabled, value) {
        try {
          setRadioParam("bendingRadioGroup_radio", enabled);
          bendingOn = enabled;
          if (enabled) {
            bendingFactor = value;
            select("#bendingVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting bending:", error);
        }
      }
      
      function setWeight(enabled, value) {
        try {
          setRadioParam("weightRadioGroup_radio", enabled);
          weightOn = enabled;
          if (enabled) {
            weight = value;
            select("#weightVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting weight:", error);
        }
      }
      
      function setRadioParam(radioName, enabled) {
        try {
          let radio = selectAll(`input[name="${radioName}"]`);
          for (let r of radio) {
            if (r.value() === (enabled ? "on" : "off")) {
              r.checked(true);
            }
          }
          
          // Update container visibility if needed
          let containerId = radioName.replace("_radio", "").replace("Radio", "Container");
          let container = select("#" + containerId);
          if (container) {
            container.style('display', enabled ? 'block' : 'none');
          }
        } catch (error) {
          console.error(`Error setting radio param ${radioName}:`, error);
        }
      }
      
      /* Educational overlay system */
      function setupEducationalOverlays() {
        try {
          // Create overlay container
          let overlayContainer = createDiv();
          overlayContainer.id('overlayContainer');
          overlayContainer.parent('canvasContainer');
          
          // Create explanation panels for different parameters
          createExplanationPanel('Damping', 
            `<h3>Damping</h3>
             <p>Damping controls how quickly the cloth loses energy. It simulates air resistance and internal friction in the fabric.</p>
             <p class="formula">velocity *= damping</p>
             <p>Higher damping (closer to 0) causes the cloth to settle quickly. Lower damping (closer to 1) allows the cloth to oscillate for longer.</p>
             <p>Real-world equivalent: Silk has lower damping than wool.</p>`
          );
          
          createExplanationPanel('Constraints', 
            `<h3>Cloth Constraints</h3>
             <p>Cloth is modeled using three types of constraints:</p>
             <ul>
               <li><strong>Structural</strong> (green lines): Maintain distance between adjacent points</li>
               <li><strong>Shear</strong> (yellow lines): Resist diagonal distortion</li>
               <li><strong>Bending</strong> (blue lines): Resist folding</li>
             </ul>
             <p>Each constraint tries to maintain its rest length by applying corrective forces.</p>
             <p class="formula">position += (current_length - rest_length) * correction_factor</p>`
          );
          
          createExplanationPanel('Integration', 
            `<h3>Verlet Integration</h3>
             <p>This simulation uses Verlet integration, a method that:</p>
             <ul>
               <li>Stores position and previous position instead of position and velocity</li>
               <li>Implicitly calculates velocity as the difference between current and previous positions</li>
             </ul>
             <p>The integration steps are:</p>
             <ol>
               <li>Calculate velocity: v = position - old_position</li>
               <li>Apply damping: v *= damping</li>
               <li>Save current position: old_position = position</li>
               <li>Apply forces and update: position += v + forces</li>
               <li>Apply constraints multiple times</li>
             </ol>
             <p class="formula">x' = x + (x - x_prev) * damping + forces</p>
             <p>Verlet integration provides good stability for cloth simulation.</p>`
          );
          
          createExplanationPanel('Stretch', 
            `<h3>Stretch Resistance</h3>
             <p>Stretch factor controls how much the cloth can extend or compress along its primary threads.</p>
             <p>Higher values make the cloth more rigid, while lower values allow it to stretch more easily.</p>
             <p>The stretch constraint applies to adjacent points in the grid and tries to maintain its rest length.</p>
             <p>Real-world equivalent: Elastic fabrics have lower stretch resistance than woven cotton.</p>`
          );
          
          createExplanationPanel('Shear', 
            `<h3>Shear Resistance</h3>
             <p>Shear factor controls how much the cloth can deform diagonally.</p>
             <p>Higher values resist diagonal deformation, creating a more rigid fabric behavior.</p>
             <p>The shear constraint applies to diagonal connections in the grid cells.</p>
             <p>Real-world equivalent: Woven fabrics typically have higher shear resistance than knits.</p>`
          );
          
          createExplanationPanel('Bending', 
            `<h3>Bending Resistance</h3>
             <p>Bending factor controls how much the cloth resists folding.</p>
             <p>Higher values create a stiffer fabric that doesn't fold easily, while lower values allow for soft creases.</p>
             <p>The bending constraint connects alternating points in the grid.</p>
             <p>Real-world equivalent: Paper has high bending resistance, while silk has low resistance.</p>`
          );
          
          createExplanationPanel('Iterations', 
            `<h3>Constraint Iterations</h3>
             <p>Iterations determine how many times constraints are applied per frame.</p>
             <p>Higher values create a more stable but computationally expensive simulation.</p>
             <p>When iterations are low, constraints might not be fully satisfied, leading to stretching.</p>
             <p>Think of this as how "perfectly" the fabric maintains its properties.</p>`
          );
          
          createExplanationPanel('Wind', 
            `<h3>Wind Forces</h3>
             <p>Wind creates external forces that push the cloth in different directions.</p>
             <p>X, Y, and Z values control the wind direction and strength along each axis.</p>
             <p>Wind buffer acts as a multiplier for the overall wind effect.</p>
             <p>Wind varies over time with a sinusoidal pattern to create natural-looking movement.</p>`
          );
          
          createExplanationPanel('Gravity', 
            `<h3>Gravity Force</h3>
             <p>Gravity controls the downward acceleration applied to the cloth.</p>
             <p>Higher values create a stronger gravitational pull.</p>
             <p>When combined with weight, it determines how fast the cloth falls and how much it stretches.</p>
             <p>Gravity primarily affects the Y-axis in this simulation.</p>`
          );
          
          createExplanationPanel('Stress', 
            `<h3>Stress Visualization</h3>
             <p>The stress visualization shows areas under tension (red) or compression (blue).</p>
             <p>It works by comparing the current area of each cloth cell with its rest area.</p>
             <p>Areas that are stretched appear red, while compressed areas appear blue.</p>
             <p>This visualization helps understand how forces distribute through the cloth.</p>`
          );
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(overlayContainer);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(toggleOverlay);
        } catch (error) {
          console.error("Error setting up educational overlays:", error);
        }
      }
      
      function createExplanationPanel(topic, htmlContent) {
        try {
          if (!window.explanationPanels) {
            window.explanationPanels = {};
          }
          
          let panel = createDiv();
          panel.parent('overlayContainer');
          panel.id('explanation_' + topic.toLowerCase().replace(' ', '_'));
          panel.html(htmlContent);
          panel.style('display', 'none');
          
          window.explanationPanels[topic] = panel;
        } catch (error) {
          console.error(`Error creating explanation panel for ${topic}:`, error);
        }
      }
      
      function showExplanation(topic) {
        try {
          // Hide all explanations
          for (let t in window.explanationPanels) {
            window.explanationPanels[t].style('display', 'none');
          }
          
          // Show requested topic
          if (window.explanationPanels && window.explanationPanels[topic]) {
            window.explanationPanels[topic].style('display', 'block');
            select('#overlayContainer').style('display', 'block');
          }
        } catch (error) {
          console.error(`Error showing explanation for ${topic}:`, error);
        }
      }
      
      function toggleOverlay() {
        try {
          let overlay = select('#overlayContainer');
          let isVisible = overlay.style('display') === 'block';
          overlay.style('display', isVisible ? 'none' : 'block');
          select('#showExplanationsBtn').html(isVisible ? 'Show Explanations' : 'Hide Explanations');
          
          // If showing overlay, display the first explanation
          if (!isVisible) {
            let firstTopic = Object.keys(window.explanationPanels)[0];
            showExplanation(firstTopic);
          }
        } catch (error) {
          console.error("Error toggling overlay:", error);
        }
      }
      
      // Add hover triggers to parameter headers
      function addExplanationTriggers() {
        try {
          // Add info icons next to parameter headers
          let params = selectAll('.paramHeader');
          for (let p of params) {
            let paramName = p.html().split(':')[0].trim();
            
            // Only add for parameters we have explanations for
            if (window.explanationPanels && window.explanationPanels[paramName]) {
              let infoIcon = createSpan('ⓘ');
              infoIcon.parent(p);
              infoIcon.class('infoIcon');
              infoIcon.mouseOver(() => {
                showExplanation(paramName);
              });
            }
          }
          
          // Add general explanation triggers
          let structureTrigger = createSpan('ⓘ');
          structureTrigger.position(10, 10);
          structureTrigger.parent(select("#shadingRadioGroup").parent());
          structureTrigger.class('infoIcon');
          structureTrigger.mouseOver(() => {
            showExplanation('Constraints');
          });
          
          let stressTrigger = createSpan('ⓘ');
          stressTrigger.position(10, 10);
          stressTrigger.parent(select("#shadingRadioGroup").parent());
          stressTrigger.class('infoIcon');
          stressTrigger.mouseOver(() => {
            showExplanation('Stress');
          });
        } catch (error) {
          console.error("Error adding explanation triggers:", error);
        }
      }
      
      /* Physics metrics visualization */
      function setupPhysicsMetrics() {
        try {
          // Create metrics panel (hidden by default)
          let metricsPanel = createDiv();
          metricsPanel.id('physicsMetrics');
          metricsPanel.style('display', 'none');
          metricsPanel.parent('canvasContainer');
          
          // Add metrics visualization elements
          let energyGraph = createDiv();
          energyGraph.parent(metricsPanel);
          energyGraph.id('energyGraph');
          energyGraph.html('<h3>Energy Analysis</h3>');
          
          let stressHeatmap = createDiv();
          stressHeatmap.parent(metricsPanel);
          stressHeatmap.id('stressHeatmap');
          stressHeatmap.html('<h3>Stress Distribution</h3>');
          
          let forceVectors = createDiv();
          forceVectors.parent(metricsPanel);
          forceVectors.id('forceVectors');
          forceVectors.html('<h3>Force Analysis</h3>');
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(metricsPanel);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(togglePhysicsPanel);
        } catch (error) {
          console.error("Error setting up physics metrics:", error);
        }
      }
      
      function togglePhysicsPanel() {
        try {
          let panel = select('#physicsMetrics');
          if (!panel) {
            setupPhysicsMetrics();
            panel = select('#physicsMetrics');
          }
          
          let isVisible = panel.style('display') === 'block';
          panel.style('display', isVisible ? 'none' : 'block');
          select('#showPhysicsBtn').html(isVisible ? 'Show Physics Metrics' : 'Hide Physics Metrics');
        } catch (error) {
          console.error("Error toggling physics panel:", error);
        }
      }
      
      function updatePhysicsMetrics() {
        try {
          let panel = select('#physicsMetrics');
          if (!panel || panel.style('display') !== 'block') return;
          
          // Calculate total kinetic energy
          let totalKE = 0;
          let sampleCount = 0;
          
          // Sample a subset of points for better performance
          const step = Math.max(1, Math.floor(clothPoints.length / 100));
          
          for (let i = 0; i < clothPoints.length; i += step) {
            let p = clothPoints[i];
            
            if (!p || p.pinned) continue;
            
            let vx = p.x - p.oldx;
            let vy = p.y - p.oldy;
            let vz = p.z - p.oldz;
            let v2 = vx*vx + vy*vy + vz*vz;
            totalKE += v2;
            sampleCount++;
          }
          
          // Scale by sample ratio
          if (sampleCount > 0) {
            totalKE = totalKE * (clothPoints.length / sampleCount);
          }
          
          // Calculate tension/compression energy from constraints
          let strainEnergy = 0;
          sampleCount = 0;
          const constraintStep = Math.max(1, Math.floor(clothConstraints.length / 100));
          
          for (let i = 0; i < clothConstraints.length; i += constraintStep) {
            if (i >= clothConstraints.length) continue;
            let c = clothConstraints[i];
            if (!c) continue;
            
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            if (!p1 || !p2) continue;
            
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dz = p2.z - p1.z;
            let d = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (d > 0 && c.length > 0) {
              let strain = Math.abs(d - c.length) / c.length;
              strainEnergy += strain * strain;
              sampleCount++;
            }
          }
          
          // Scale by sample ratio
          if (sampleCount > 0) {
            strainEnergy = strainEnergy * (clothConstraints.length / sampleCount);
          }
          
          // Update energy info
          let energyInfo = `<h3>Energy Analysis</h3>
                           <p>Kinetic Energy: ${nf(totalKE, 1, 2)}</p>
                           <p>Strain Energy: ${nf(strainEnergy, 1, 2)}</p>
                           <p>Total Energy: ${nf(totalKE + strainEnergy, 1, 2)}</p>
                           <p>Simulation FPS: ${nf(frameRate, 1, 1)}</p>`;
          
          select('#energyGraph').html(energyInfo);
          
          // Update stress info - lower sampling rate for performance
          let maxStress = 0;
          let avgStress = 0;
          let stressCount = 0;
          
          // Compute stress from cell areas
          const rowStep = Math.max(1, Math.floor(rows / 5));
          const colStep = Math.max(1, Math.floor(cols / 5));
          
          for (let y = 0; y < rows - 1; y += rowStep) {
            for (let x = 0; x < cols - 1; x += colStep) {
              // Check if we have valid indices
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) {
                continue;
              }
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              // Check for valid points
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) {
                continue;
              }
              
              // Check if we have valid rest area data
              if (!cellRestArea[y] || cellRestArea[y][x] === undefined) {
                continue;
              }
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              
              let currArea = computeQuadArea(A, B, C, D);
              let restArea = cellRestArea[y][x];
              
              if (restArea > 0) {
                let diff = Math.abs(currArea - restArea) / restArea;
                maxStress = Math.max(maxStress, diff);
                avgStress += diff;
                stressCount++;
              }
            }
          }
          
          if (stressCount > 0) {
            avgStress = avgStress / stressCount;
          }
          
          let stressInfo = `<h3>Stress Analysis</h3>
                           <p>Maximum Stress: ${nf(maxStress * 100, 1, 2)}%</p>
                           <p>Average Stress: ${nf(avgStress * 100, 1, 2)}%</p>`;
          
          select('#stressHeatmap').html(stressInfo);
          
          // Update force info
          let gravityForce = gravityOn ? (gravity * weight) : 0;
          let windForce = Math.sqrt(windX*windX + windY*windY + windZ*windZ);
          windForce = (windXOn || windYOn || windZOn) ? windForce : 0;
          
          let forceInfo = `<h3>Force Analysis</h3>
                          <p>Gravity Force: ${nf(gravityForce, 1, 2)}</p>
                          <p>Wind Force: ${nf(windForce, 1, 2)}</p>
                          <p>Cloth Points: ${clothPoints.length}</p>
                          <p>Constraints: ${clothConstraints.length}</p>`;
          
          select('#forceVectors').html(forceInfo);
        } catch (error) {
          console.error("Error updating physics metrics:", error);
        }
      }
      
      /* Comparison view between real fabric and simulation */
      function toggleComparisonView() {
        try {
          // Create comparison overlay if it doesn't exist
          if (!select('#comparisonOverlay')) {
            createComparisonOverlay();
          }
          
          let overlay = select('#comparisonOverlay');
          let isVisible = overlay.style('display') === 'block';
          overlay.style('display', isVisible ? 'none' : 'block');
          select('#showComparisonBtn').html(isVisible ? 'Show Real vs. Simulated' : 'Hide Comparison');
        } catch (error) {
          console.error("Error toggling comparison view:", error);
        }
      }
      
      function createComparisonOverlay() {
        try {
          // Create comparison overlay
          let comparisonOverlay = createDiv();
          comparisonOverlay.id('comparisonOverlay');
          comparisonOverlay.parent('canvasContainer');
          
          // Add title
          let comparisonTitle = createElement('h3', 'Real vs. Simulated Cloth');
          comparisonTitle.parent(comparisonOverlay);
          
          // Add comparison content
          let comparisonContent = createDiv();
          comparisonContent.parent(comparisonOverlay);
          comparisonContent.id('comparisonContent');
          
          let html = '';
          html += '<div style="margin-bottom: 15px;">';
          html += '<p>Real fabrics behave differently than simulated cloth due to:</p>';
          html += '<ul>';
          html += '<li>Complex fiber structures that our simulation approximates</li>';
          html += '<li>Varying material properties throughout the fabric</li>';
          html += '<li>Different behavior in warp vs. weft directions</li>';
          html += '<li>Complex interactions between fibers</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Silk</h4>';
          html += '<p>Real silk drapes fluidly with a lustrous appearance. Our simulation approximates this with:</p>';
          html += '<ul>';
          html += '<li>Low bending resistance (0.7)</li>';
          html += '<li>High damping (0.99)</li>';
          html += '<li>Low weight (0.7)</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Denim</h4>';
          html += '<p>Real denim is stiff and heavy. Our simulation models this with:</p>';
          html += '<ul>';
          html += '<li>High bending resistance (1.1)</li>';
          html += '<li>Lower damping (0.95)</li>';
          html += '<li>Higher weight (1.2)</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Experiment</h4>';
          html += '<p>Try draping different fabric presets over the sphere to compare their behavior!</p>';
          html += '</div>';
          
          comparisonContent.html(html);
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(comparisonOverlay);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(() => {
            comparisonOverlay.style('display', 'none');
            select('#showComparisonBtn').html('Show Real vs. Simulated');
          });
        } catch (error) {
          console.error("Error creating comparison overlay:", error);
        }
      }
      
      /* Guided learning system */
      function setupGuidedLearning() {
        try {
          // Create learning panel
          let learningPanel = createDiv();
          learningPanel.id('learningPanel');
          learningPanel.parent('canvasContainer');
          learningPanel.style('display', 'none');
          
          // Scenario selector
          let scenarioSelect = createSelect();
          scenarioSelect.parent(learningPanel);
          scenarioSelect.id('scenarioSelect');
          for (let i = 0; i < LEARNING_SCENARIOS.length; i++) {
            scenarioSelect.option(LEARNING_SCENARIOS[i].title, i);
          }
          scenarioSelect.changed(scenarioChanged);
          
          // Title and content divs
          let stepTitle = createDiv();
          stepTitle.parent(learningPanel);
          stepTitle.id('stepTitle');
          
          let stepInstructions = createDiv();
          stepInstructions.parent(learningPanel);
          stepInstructions.id('stepInstructions');
          
          let stepExplanation = createDiv();
          stepExplanation.parent(learningPanel);
          stepExplanation.id('stepExplanation');
          
          // Navigation buttons
          let btnContainer = createDiv();
          btnContainer.parent(learningPanel);
          btnContainer.style('display', 'flex');
          btnContainer.style('justify-content', 'space-between');
          btnContainer.style('margin-top', '15px');
          
          let prevBtn = createButton('« Previous');
          prevBtn.parent(btnContainer);
          prevBtn.id('prevStepBtn');
          prevBtn.style('width', '48%');
          prevBtn.mousePressed(previousStep);
          
          let nextBtn = createButton('Next »');
          nextBtn.parent(btnContainer);
          nextBtn.id('nextStepBtn');
          nextBtn.style('width', '48%');
          nextBtn.mousePressed(nextStep);
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(learningPanel);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(toggleGuidedLearning);
        } catch (error) {
          console.error("Error setting up guided learning:", error);
        }
      }
      
      function toggleGuidedLearning() {
        try {
          guidedLearningActive = !guidedLearningActive;
          
          if (!select('#learningPanel')) {
            setupGuidedLearning();
          }
          
          select('#learningPanel').style('display', guidedLearningActive ? 'block' : 'none');
          select('#startLearningBtn').html(guidedLearningActive ? 'End Guided Learning' : 'Start Guided Learning');
          
          if (guidedLearningActive) {
            currentStep = 0;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error toggling guided learning:", error);
        }
      }
      
      function scenarioChanged() {
        try {
          if (guidedLearningActive) {
            currentStep = 0;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error changing scenario:", error);
        }
      }
      
      function nextStep() {
        try {
          let scenarioIndex = select('#scenarioSelect').value();
          let scenario = LEARNING_SCENARIOS[scenarioIndex];
          
          if (currentStep < scenario.steps.length - 1) {
            currentStep++;
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error going to next step:", error);
        }
      }
      
      function previousStep() {
        try {
          if (currentStep > 0) {
            currentStep--;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error going to previous step:", error);
        }
      }
      
      function updateLearningPanel(scenarioIndex, stepIndex) {
        try {
          let scenario = LEARNING_SCENARIOS[scenarioIndex];
          let step = scenario.steps[stepIndex];
          
          select('#stepTitle').html('<h3>' + step.title + '</h3>');
          select('#stepInstructions').html('<p>' + step.instructions + '</p>');
          select('#stepExplanation').html('<div class="paramDesc">' + step.explanation + '</div>');
          
          // Update button states
          select('#prevStepBtn').attribute('disabled', stepIndex === 0 ? true : null);
          select('#nextStepBtn').attribute('disabled', stepIndex === scenario.steps.length - 1 ? true : null);
          
          // Apply setup for this step
          if (step.setup) {
            try {
              step.setup();
            } catch (error) {
              console.error("Error in guided learning step setup:", error);
              showError("Error running learning step. Please try another step.");
            }
          }
        } catch (error) {
          console.error("Error updating learning panel:", error);
        }
      }
      
      /* EVENT LISTENERS */
      // Window load event
      window.addEventListener('load', function() {
        try {
          // Handle loading screen
          setTimeout(function() {
            select('#loadingOverlay').style('display', 'none');
            
            // Check for WebGL support
            const canvas = document.getElementById('defaultCanvas0');
            if (!canvas) {
              showError("Error: Canvas not initialized. Please try refreshing the page or using a different browser.");
            }
          }, 2000);
          
          // Auto-detect device capabilities
          if (windowWidth <= 768 || windowHeight <= 500) {
            // Mobile device - use lower resolution
            setSimulationQuality("low");
          } else {
            // Check if we have GPU acceleration
            const testCanvas = document.createElement('canvas');
            const testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
            
            if (!testContext || testContext.getSupportedExtensions().length < 10) {
              // Limited WebGL support - use medium quality
              setSimulationQuality("medium");
            }
          }
        } catch (error) {
          console.error("Error in window load handler:", error);
        }
      });
      
      // Performance monitoring toggle
      window.addEventListener('keydown', function(e) {
        if (e.key === 'p' || e.key === 'P') {
          showPerformanceMetrics = !showPerformanceMetrics;
          select('#performanceIndicator').style('display', showPerformanceMetrics ? 'block' : 'none');
        }
      });
    </script>
  </body>
</html>
