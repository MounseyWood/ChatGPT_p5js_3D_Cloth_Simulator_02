<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced 3D Cloth Simulation – Educational Edition</title>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
    <style>
      /* Global Layout & Colours */
      body, html {
        margin: 0;
        padding: 0;
        background: #0b0e14;
        color: #edf2f7;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        height: 100%;
        overflow: hidden;
      }
      #uiPanel {
        position: absolute;
        top: 0;
        left: 0;
        width: 280px;
        height: 100%;
        background: #1a202c;
        box-shadow: 2px 0 8px rgba(0,0,0,0.5);
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4a5568 #1a202c;
        z-index: 10;
        transition: transform 0.3s ease;
      }
      #uiPanel::-webkit-scrollbar {
        width: 8px;
      }
      #uiPanel::-webkit-scrollbar-track {
        background: #1a202c;
      }
      #uiPanel::-webkit-scrollbar-thumb {
        background-color: #4a5568;
        border-radius: 4px;
      }
      #canvasContainer {
        position: absolute;
        top: 0;
        left: 280px;
        width: calc(100% - 280px);
        height: 100%;
        overflow: hidden;
        transition: left 0.3s ease, width 0.3s ease;
      }
      #menuToggle {
        display: none;
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 100;
        padding: 8px 12px;
        background: #2d3748;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      h2 {
        margin-top: 0;
        margin-bottom: 16px;
        color: #63b3ed;
        font-weight: 600;
        font-size: 1.5rem;
      }
      h3 {
        color: #63b3ed;
        font-weight: 600;
        font-size: 1.2rem;
        margin-top: 1rem;
        margin-bottom: 0.75rem;
      }
      p, label {
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: 12px;
        color: #e2e8f0;
      }
      .parameter {
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid #2d3748;
      }
      .paramHeader {
        margin-bottom: 6px;
        font-weight: bold;
        display: flex;
        align-items: center;
        color: #a0aec0;
      }
      .paramRadio {
        display: flex;
        gap: 12px;
        margin-bottom: 6px;
      }
      .paramRadio input[type="radio"] {
        accent-color: #4299e1;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #4299e1;
        margin: 8px 0;
      }
      .paramContainer {
        margin-top: 6px;
        display: none; /* Hidden until "on" is selected */
      }
      .paramDesc {
        font-size: 12px;
        color: #a0aec0;
        margin-top: 6px;
        line-height: 1.4;
      }
      /* Sticky bottom buttons */
      .bottomButtons {
        position: sticky;
        bottom: 20px;
        width: 100%;
      }
      button {
        width: 100%;
        padding: 10px 14px;
        background: #2d3748;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 10px;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      button:hover {
        background: #4a5568;
      }
      button:active {
        transform: translateY(1px);
      }
      button:disabled {
        background: #2d3748;
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* Educational overlays */
      #overlayContainer {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 340px;
        background: rgba(26, 32, 44, 0.95);
        color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        display: none;
        max-height: 80%;
        overflow-y: auto;
        z-index: 100;
        backdrop-filter: blur(4px);
        border: 1px solid #4a5568;
      }
      
      /* Physics Metrics panel */
      #physicsMetrics {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 300px;
        background: rgba(26, 32, 44, 0.95);
        color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 90;
        backdrop-filter: blur(4px);
        border: 1px solid #4a5568;
      }
      
      /* Time-lapse overlay */
      #timelapseOverlay {
        z-index: 100;
        backdrop-filter: blur(4px);
        border: 1px solid #4a5568;
      }
      
      /* Comparison overlay */
      #comparisonOverlay {
        z-index: 100;
        width: 600px;
        max-width: 80%;
        backdrop-filter: blur(4px);
        border: 1px solid #4a5568;
      }
      
      /* Info icons */
      .infoIcon {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        width: 16px;
        height: 16px;
        margin-left: 8px;
        border-radius: 50%;
        background: #4299e1;
        color: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .infoIcon:hover {
        background: #2b6cb0;
      }
      
      /* Tutorial panel */
      #learningPanel {
        z-index: 100;
        backdrop-filter: blur(4px);
        border: 1px solid #4a5568;
      }
      #learningPanel select,
      #learningPanel button {
        margin: 10px 0;
      }
      #stepTitle {
        color: #63b3ed;
      }
      #stepExplanation {
        font-size: 14px;
        line-height: 1.6;
      }
      
      /* Section headers */
      .sectionTitle {
        margin-top: 20px;
        font-weight: 600;
        padding-bottom: 6px;
        border-bottom: 2px solid #4299e1;
        color: #63b3ed;
      }
      
      /* Dropdown styling */
      select {
        width: 100%;
        padding: 8px 10px;
        border-radius: 4px;
        background: #2d3748;
        color: white;
        border: 1px solid #4a5568;
        cursor: pointer;
      }
      
      /* Tooltip */
      .tooltip {
        position: absolute;
        background: rgba(26, 32, 44, 0.95);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        max-width: 200px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
      }
      
      /* Diagram images in educational overlays */
      .diagram {
        width: 100%;
        border-radius: 4px;
        margin: 10px 0;
        background: #2d3748;
        padding: 10px;
        box-sizing: border-box;
      }
      
      /* Formula styling */
      .formula {
        font-family: monospace;
        background: #2d3748;
        padding: 8px 12px;
        border-radius: 4px;
        display: inline-block;
        margin: 6px 0;
      }
      
      /* Tab navigation for different parameter groups */
      .tabs {
        display: flex;
        margin-bottom: 15px;
        border-bottom: 1px solid #4a5568;
      }
      .tab {
        padding: 8px 12px;
        cursor: pointer;
        background: transparent;
        border: none;
        color: #a0aec0;
        font-size: 14px;
        margin-right: 2px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
        width: auto;
        margin-bottom: 0;
      }
      .tab.active {
        color: #63b3ed;
        border-bottom: 2px solid #4299e1;
      }
      .tab:hover:not(.active) {
        color: #e2e8f0;
        background: transparent;
      }
      .tabContent {
        display: none;
      }
      .tabContent.active {
        display: block;
      }
      
      /* Material preset cards */
      .materialPresets {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }
      .materialCard {
        width: calc(50% - 5px);
        background: #2d3748;
        border-radius: 4px;
        padding: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .materialCard:hover {
        background: #4a5568;
      }
      .materialCard.active {
        border: 1px solid #4299e1;
        background: #2b6cb0;
      }
      .materialName {
        font-weight: bold;
        margin-bottom: 4px;
      }
      .materialDesc {
        font-size: 11px;
        color: #a0aec0;
      }
      
      /* Slider value label */
      .sliderValue {
        float: right;
        font-weight: normal;
      }
      
      /* Animation controls */
      .animControls {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
      }
      .animBtn {
        flex: 1;
        padding: 8px 4px;
        font-size: 12px;
      }
      
      /* Logo and credits */
      .appHeader {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
      }
      .appLogo {
        width: 40px;
        height: 40px;
        background: #4299e1;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: white;
        font-weight: bold;
        font-size: 18px;
      }
      .appTitle {
        flex: 1;
      }
      .appTitle h2 {
        margin: 0;
        line-height: 1.2;
      }
      .appVersion {
        font-size: 11px;
        color: #a0aec0;
      }
      
      /* Loading indicator */
      #loadingOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(26, 32, 44, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #4299e1;
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* Performance indicator */
      #performanceIndicator {
        position: absolute;
        top: 10px;
        left: 290px;
        background: rgba(26, 32, 44, 0.7);
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        color: white;
        display: none;
      }
      
      /* Responsive layout */
      @media (max-width: 768px) {
        #menuToggle {
          display: block;
        }
        #uiPanel {
          transform: translateX(-100%);
          width: 250px;
        }
        #uiPanel.active {
          transform: translateX(0);
        }
        #canvasContainer {
          left: 0;
          width: 100%;
        }
        #overlayContainer,
        #physicsMetrics,
        #learningPanel,
        #comparisonOverlay,
        #timelapseOverlay {
          width: 90%;
          max-width: 90%;
          left: 5%;
          right: 5%;
        }
      }
      
      /* Error message */
      #errorMessage {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: #e53e3e;
        color: white;
        padding: 10px 15px;
        border-radius: 4px;
        z-index: 1001;
        display: none;
        max-width: 80%;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <p>Loading Cloth Simulator...</p>
    </div>
    
    <!-- Error Message -->
    <div id="errorMessage"></div>
    
    <!-- Performance Indicator -->
    <div id="performanceIndicator"></div>
    
    <!-- Mobile Menu Toggle -->
    <button id="menuToggle">☰ Menu</button>
    
    <!-- UI Panel -->
    <div id="uiPanel">
      <div class="appHeader">
        <div class="appLogo">CS</div>
        <div class="appTitle">
          <h2>3D Cloth Simulator</h2>
          <div class="appVersion">Educational Edition v1.2</div>
        </div>
      </div>

      <!-- Tabs for organizing controls -->
      <div class="tabs">
        <button class="tab active" onclick="showTab('simTab')">Simulation</button>
        <button class="tab" onclick="showTab('matTab')">Materials</button>
        <button class="tab" onclick="showTab('forceTab')">Forces</button>
        <button class="tab" onclick="showTab('learnTab')">Learning</button>
      </div>

      <!-- Simulation Tab -->
      <div id="simTab" class="tabContent active">
        <p>
          Two main simulation modes: <strong>Plane</strong> or <strong>Draped</strong>.<br>
          Adjust parameters to see how they affect cloth behavior.
        </p>

        <!-- Simulation Mode -->
        <div class="parameter">
          <div class="paramHeader">Simulation Mode:</div>
          <div id="simModeRadio"></div>
          <div class="paramDesc">
            <strong>Plane</strong>: pinned cloth in free space.<br>
            <strong>Draped</strong>: cloth drapes over a form.
          </div>
        </div>

        <!-- Form Mode (only relevant in Draped mode) -->
        <div class="parameter" id="formModeParam">
          <div class="paramHeader">Form Mode:</div>
          <div id="formModeRadio"></div>
          <div class="paramDesc">
            Choose <strong>Sphere</strong> or <strong>Cylinder</strong> as the underlying form.
          </div>
        </div>

        <!-- Interaction Mode -->
        <div class="parameter">
          <div class="paramHeader">Interaction Mode:</div>
          <div id="interactionRadioGroup"></div>
          <div class="paramDesc">
            "Rotate" = move the camera; "Drag" = pick cloth points.
          </div>
        </div>

        <!-- Pinning Mode (only for Plane mode) -->
        <div class="parameter">
          <div class="paramHeader">Pinning Mode:</div>
          <div id="pinningRadio"></div>
          <div class="paramDesc">Only relevant in Plane mode.</div>
        </div>

        <!-- Shading Mode -->
        <div class="parameter">
          <div class="paramHeader">Visualization Mode:</div>
          <div class="paramRadio" id="shadingRadioGroup"></div>
          <div class="paramDesc">
            <strong>Off:</strong> Lines only<br>
            <strong>Cloth:</strong> Solid surface<br>
            <strong>Overlaid:</strong> Surface with structure<br>
            <strong>Stress:</strong> Tension/compression<br>
            <strong>Structure:</strong> Constraint types
          </div>
        </div>

        <!-- Cloth Resolution -->
        <div class="parameter">
          <div class="paramHeader">Cloth Resolution: <span id="resolutionVal"></span></div>
          <div id="resolutionSlider"></div>
          <div class="paramDesc">Higher values create more detailed cloth (slower).</div>
        </div>
        
        <!-- Quality Settings -->
        <div class="parameter">
          <div class="paramHeader">Quality Settings:</div>
          <div class="paramRadio" id="qualityRadioGroup"></div>
          <div class="paramDesc">
            Lower quality for better performance on slower devices.
          </div>
        </div>
      </div>

      <!-- Materials Tab -->
      <div id="matTab" class="tabContent">
        <div class="sectionTitle">Fabric Presets</div>
        <p>Select a preset to automatically configure cloth material properties.</p>
        
        <div class="materialPresets" id="materialPresetCards">
          <!-- Material cards will be added here via JavaScript -->
        </div>
        
        <div id="fabricDescription" class="paramDesc" style="margin: 10px 0;">
          Select a fabric to see its properties.
        </div>
        
        <div class="sectionTitle">Material Properties</div>
        
        <!-- Damping -->
        <div class="parameter">
          <div class="paramHeader">Damping: <span id="dampingVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="dampingRadioGroup"></div>
          <div id="dampingContainer" class="paramContainer">
            <div id="dampingSlider"></div>
            <div class="paramDesc">Controls energy loss. Lower = more damping.</div>
          </div>
        </div>

        <!-- Iterations -->
        <div class="parameter">
          <div class="paramHeader">Iterations: <span id="iterationsVal" class="sliderValue">1</span></div>
          <div class="paramRadio" id="iterationsRadioGroup"></div>
          <div id="iterationsContainer" class="paramContainer">
            <div id="iterationsSlider"></div>
            <div class="paramDesc">Constraint relaxations per frame. Higher = more stable.</div>
          </div>
        </div>

        <!-- Stretch -->
        <div class="parameter">
          <div class="paramHeader">Stretch: <span id="stretchVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="stretchRadioGroup"></div>
          <div id="stretchContainer" class="paramContainer">
            <div id="stretchSlider"></div>
            <div class="paramDesc">Affects cloth extension. Higher = less stretchy.</div>
          </div>
        </div>

        <!-- Shear -->
        <div class="parameter">
          <div class="paramHeader">Shear: <span id="shearVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="shearRadioGroup"></div>
          <div id="shearContainer" class="paramContainer">
            <div id="shearSlider"></div>
            <div class="paramDesc">Resists diagonal distortion. Higher = less deformable.</div>
          </div>
        </div>

        <!-- Bending -->
        <div class="parameter">
          <div class="paramHeader">Bending: <span id="bendingVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="bendingRadioGroup"></div>
          <div id="bendingContainer" class="paramContainer">
            <div id="bendingSlider"></div>
            <div class="paramDesc">Resistance to sharp folds. Higher = stiffer fabric.</div>
          </div>
        </div>

        <!-- Weight -->
        <div class="parameter">
          <div class="paramHeader">Weight: <span id="weightVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="weightRadioGroup"></div>
          <div id="weightContainer" class="paramContainer">
            <div id="weightSlider"></div>
            <div class="paramDesc">Fabric mass. Higher = heavier cloth.</div>
          </div>
        </div>
      </div>

      <!-- Forces Tab -->
      <div id="forceTab" class="tabContent">
        <div class="sectionTitle">Gravity</div>
        
        <!-- Gravity -->
        <div class="parameter">
          <div class="paramHeader">Gravity: <span id="gravityVal" class="sliderValue">0.00</span></div>
          <div class="paramRadio" id="gravityRadioGroup"></div>
          <div id="gravityContainer" class="paramContainer">
            <div id="gravitySlider"></div>
            <div class="paramDesc">Downward acceleration (0-1).</div>
          </div>
        </div>
        
        <div class="sectionTitle">Wind Forces</div>
        
        <!-- Wind X -->
        <div class="parameter">
          <div class="paramHeader">Wind X: <span id="windXVal" class="sliderValue">0.00</span></div>
          <div class="paramRadio" id="windXRadioGroup"></div>
          <div id="windXContainer" class="paramContainer">
            <div id="windXSlider"></div>
            <div class="paramDesc">Wind force along X axis (-1 to 1).</div>
          </div>
        </div>

        <!-- Wind Y -->
        <div class="parameter">
          <div class="paramHeader">Wind Y: <span id="windYVal" class="sliderValue">0.00</span></div>
          <div class="paramRadio" id="windYRadioGroup"></div>
          <div id="windYContainer" class="paramContainer">
            <div id="windYSlider"></div>
            <div class="paramDesc">Wind force along Y axis (-1 to 1).</div>
          </div>
        </div>

        <!-- Wind Z -->
        <div class="parameter">
          <div class="paramHeader">Wind Z: <span id="windZVal" class="sliderValue">0.00</span></div>
          <div class="paramRadio" id="windZRadioGroup"></div>
          <div id="windZContainer" class="paramContainer">
            <div id="windZSlider"></div>
            <div class="paramDesc">Wind force along Z axis (-1 to 1).</div>
          </div>
        </div>

        <!-- Wind Buffer -->
        <div class="parameter">
          <div class="paramHeader">Wind Buffer: <span id="windBufVal" class="sliderValue">1.00</span></div>
          <div class="paramRadio" id="windBufRadioGroup"></div>
          <div id="windBufContainer" class="paramContainer">
            <div id="windBufSlider"></div>
            <div class="paramDesc">Scales overall wind strength (0-2).</div>
          </div>
        </div>
        
        <div class="sectionTitle">Animation Presets</div>
        <select id="animationPresetSelect">
          <option value="">Select animation preset...</option>
          <option value="breeze">Gentle Breeze</option>
          <option value="gust">Strong Wind Gust</option>
          <option value="drop">Fabric Drop</option>
          <option value="material">Material Test</option>
          <option value="gravity">Gravity Increase</option>
        </select>
        
        <div class="sectionTitle">Recording</div>
        <div class="animControls">
          <button class="animBtn" id="recordBtn">Start Recording</button>
          <button class="animBtn" id="playBtn" disabled>Play Animation</button>
        </div>
        <button id="timelapseBtn">Create Time-lapse</button>
      </div>

      <!-- Learning Tab -->
      <div id="learnTab" class="tabContent">
        <div class="sectionTitle">Educational Tools</div>
        <p>Learn about cloth physics and simulation through interactive guides and visualizations.</p>
        
        <button id="showExplanationsBtn">Show Explanations</button>
        <button id="showPhysicsBtn">Show Physics Metrics</button>
        <button id="startLearningBtn">Start Guided Learning</button>
        <button id="showComparisonBtn">Show Real vs. Simulated</button>
        
        <div class="sectionTitle">About This Simulation</div>
        <p>
          This 3D cloth simulator demonstrates the physics of fabric using a mass-spring model with position-based dynamics.
        </p>
        <p>
          The simulation uses three types of constraints:
        </p>
        <ul>
          <li><strong>Structural</strong> - Maintains cloth shape</li>
          <li><strong>Shear</strong> - Prevents diagonal deformation</li>
          <li><strong>Bending</strong> - Controls fold resistance</li>
        </ul>
        <p>
          Experiment with different parameters to see how they affect cloth behavior!
        </p>
      </div>

      <div class="bottomButtons">
        <button id="playPauseBtn">Pause Simulation</button>
        <button id="resetOrientationBtn">Reset Orientation</button>
        <button id="resetBtn">Reset Cloth</button>
      </div>
    </div>

    <div id="canvasContainer"></div>

    <script>
      /* PERFORMANCE OPTIMIZATION VARIABLES */
      let lastFrameTime = 0;
      let frameRate = 0;
      let frameCount = 0;
      let frameRateArray = [];
      let showPerformanceMetrics = false;
      let simulationQuality = "high"; // "low", "medium", "high"
      let adaptiveRendering = true; // Automatically adjust quality if necessary
      
      /* CLOTH SETTINGS */
      let cols = 20, rows = 20, spacing = 20;
      let clothPoints = [], clothConstraints = [];
      let grid = [], horizontal = [], vertical = [], centers = [];

      /* SPHERE for Draped mode */
      let sphereCentre = { x: 0, y: 0, z: 0 };
      let sphereRadius = 100;

      /* CYLINDER parameters for Draped mode */
      let cylRadius = 100;
      let cylHeight = 300;
      let cylinderTopY = -50;
      let cylinderBottomY = cylinderTopY + cylHeight; // 250

      /* Invisible floor */
      let floorY = 150;

      /* SIMULATION PARAMETERS (default) */
      let damping = 0.98;
      let iterations = 5;
      let stretchFactor = 1.0;
      let shearFactor = 1.0;
      let bendingFactor = 1.0;
      let weight = 1.0;
      let windX = 0.2, windY = 0, windZ = 0.1;
      let windBuffer = 1.0;
      let gravity = 0.4;

      /* BASELINE (Off) values */
      const BASE_DAMPING = 1.0;
      const BASE_ITERATIONS = 1;
      const BASE_STRETCH = 1.0;
      const BASE_SHEAR = 1.0;
      const BASE_BENDING = 1.0;
      const BASE_WEIGHT = 1.0;
      const BASE_WINDX = 0.0, BASE_WINDY = 0.0, BASE_WINDZ = 0.0;
      const BASE_WINDBUFFER = 1.0;
      const BASE_GRAVITY = 0.0;

      /* FLAGS for each parameter */
      let dampingOn = false;
      let iterationsOn = false;
      let stretchOn = false;
      let shearOn = false;
      let bendingOn = false;
      let weightOn = false;
      let windXOn = false;
      let windYOn = false;
      let windZOn = false;
      let windBufOn = false;
      let gravityOn = false;

      // Shading modes
      let shadingMode = "off"; // "off", "cloth", "overlaid", "stress", "structure"

      /* MODES */
      let pinningMode = "top";         // Only for Plane mode
      let interactionMode = "rotate";  // "rotate" or "drag"
      let simulationMode = "plane";    // "plane" or "draped"
      let formMode = "sphere";         // For Draped mode: "sphere" or "cylinder"

      /* CLOTH POSITIONING */
      let clothShiftX = -40;

      /* ORIENTATION RESET FLAG */
      let doResetOrientation = false;

      /* PLAY/PAUSE FLAG */
      let simulationRunning = true;

      /* 3D DRAGGING VARIABLES */
      let dragPointIndex = null;
      let dragPlaneZ = 0;

      // For Stress shading, store each cell's rest area
      let cellRestArea = [];

      // For Structure shading, track constraint type
      const STRUCTURAL = "structural";
      const SHEAR = "shear";
      const BENDING = "bending";
      
      // Real-world fabric templates
      const FABRIC_PRESETS = {
        "cotton": {
          name: "Cotton",
          properties: {
            damping: 0.97,
            stretch: 0.95,
            bending: 0.95,
            shear: 0.95,
            weight: 0.9,
            description: "Medium-weight fabric with moderate stretch and stiffness."
          }
        },
        "silk": {
          name: "Silk",
          properties: {
            damping: 0.99,
            stretch: 1.1,
            bending: 0.7,
            shear: 0.8,
            weight: 0.7,
            description: "Lightweight fabric with low bending resistance and high sheen."
          }
        },
        "denim": {
          name: "Denim",
          properties: {
            damping: 0.95,
            stretch: 0.85,
            bending: 1.1,
            shear: 1.1,
            weight: 1.2,
            description: "Heavy, sturdy fabric with high bending resistance and weight."
          }
        },
        "wool": {
          name: "Wool",
          properties: {
            damping: 0.96,
            stretch: 1.0,
            bending: 0.9,
            shear: 0.9,
            weight: 1.1,
            description: "Warm fabric with moderate stretch and good drape."
          }
        },
        "lycra": {
          name: "Lycra/Spandex",
          properties: {
            damping: 0.98,
            stretch: 1.3,
            bending: 0.8,
            shear: 0.7,
            weight: 0.8,
            description: "Highly stretchy synthetic fabric with good recovery."
          }
        },
        "canvas": {
          name: "Canvas",
          properties: {
            damping: 0.94,
            stretch: 0.8,
            bending: 1.2,
            shear: 1.2,
            weight: 1.3,
            description: "Very stiff, heavyweight fabric with minimal stretch."
          }
        },
        "chiffon": {
          name: "Chiffon",
          properties: {
            damping: 0.98,
            stretch: 1.05,
            bending: 0.6,
            shear: 0.7,
            weight: 0.5,
            description: "Very lightweight, sheer fabric with excellent drape."
          }
        }
      };
      
      /* GUIDED LEARNING SCENARIOS */
      const LEARNING_SCENARIOS = [
        {
          title: "Basic Cloth Behavior",
          steps: [
            {
              title: "Gravity and Weight",
              instructions: "We'll start with a simple cloth plane and observe how gravity affects it.",
              setup: () => {
                // Set parameters for this step
                setSimulationMode("plane");
                setPinningMode("top");
                setGravity(true, 0.4);
                setWind(false, 0, 0, 0);
                setDamping(true, 0.98);
                setWeight(true, 1.0);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "Observe how the cloth hangs under gravity. The weight parameter controls how heavy the cloth appears, affecting how much it stretches."
            },
            {
              title: "Wind Effects",
              instructions: "Now let's introduce some wind to see how the cloth responds to external forces.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("top");
                setGravity(true, 0.4);
                setWind(true, 0.3, 0, 0.1);
                setWindBuffer(true, 1.0);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "Wind creates complex rippling patterns in the cloth. The wind strength and direction can be adjusted to create different effects. Notice how the cloth billows and creates natural-looking waves."
            },
            {
              title: "Material Properties",
              instructions: "Let's explore how different material properties affect the cloth behavior.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("top");
                setStretch(true, 1.1);
                setBending(true, 0.9);
                setGravity(true, 0.4);
                setWind(true, 0.1, 0, 0.05);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "Material properties like stretch and bending resistance define how the cloth behaves. Higher stretch resistance (>1.0) makes the cloth less elastic, while lower values make it stretchier. Bending resistance affects how easily the cloth forms creases and folds."
            }
          ]
        },
        {
          title: "Understanding Constraints",
          steps: [
            {
              title: "Structural Constraints",
              instructions: "Let's examine the structural constraints that form the basic grid of the cloth.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("corners");
                setStretch(true, 1.0);
                setShear(false, 1.0);
                setBending(false, 1.0);
                setShadingMode("structure");
                resetCloth();
              },
              explanation: "Structural constraints (green lines) maintain distance between adjacent points in the cloth grid. They resist stretching and compression along the main threads of the fabric."
            },
            {
              title: "Shear Constraints",
              instructions: "Now let's add shear constraints to see how they affect cloth behavior.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("corners");
                setStretch(true, 1.0);
                setShear(true, 1.0);
                setBending(false, 1.0);
                setShadingMode("structure");
                resetCloth();
              },
              explanation: "Shear constraints (yellow diagonal lines) prevent the cloth from freely deforming in diagonal directions. They maintain the rectangular structure of each grid cell, like the bias resistance in woven fabrics."
            },
            {
              title: "Bending Constraints",
              instructions: "Finally, let's add bending constraints to complete the cloth model.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("corners");
                setStretch(true, 1.0);
                setShear(true, 1.0);
                setBending(true, 1.0);
                setShadingMode("structure");
                resetCloth();
              },
              explanation: "Bending constraints (blue lines) connect alternating points in the grid. They resist folding and creasing of the cloth, acting similar to the fabric's stiffness or thickness."
            }
          ]
        },
        {
          title: "Stress Analysis",
          steps: [
            {
              title: "Visualizing Stress",
              instructions: "Let's observe how stress is distributed in a hanging cloth.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("top");
                setGravity(true, 0.4);
                setWind(false, 0, 0, 0);
                setShadingMode("stress");
                resetCloth();
              },
              explanation: "The stress visualization shows areas under tension (red) or compression (blue). Notice how the stress concentrates near the pinned points where the cloth is hanging from."
            },
            {
              title: "Draping Stress",
              instructions: "Now let's see how stress is distributed when cloth drapes over an object.",
              setup: () => {
                setSimulationMode("draped");
                setFormMode("sphere");
                setGravity(true, 0.4);
                setShadingMode("stress");
                resetCloth();
              },
              explanation: "When cloth drapes over an object, stress is distributed differently. Areas in contact with the object show compression, while sections hanging freely show tension. This is similar to how real fabrics behave when draped."
            }
          ]
        },
        {
          title: "Collision Physics",
          steps: [
            {
              title: "Self-Collision",
              instructions: "Let's observe how cloth interacts with itself through self-collision.",
              setup: () => {
                setSimulationMode("plane");
                setPinningMode("corners");
                setGravity(true, 0.5);
                setWind(true, 0.1, 0, 0.3);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "As the cloth moves and folds, it may intersect with itself. Self-collision detection prevents cloth from passing through itself, creating realistic folding behavior."
            },
            {
              title: "Object Collision",
              instructions: "Now let's see how cloth interacts with solid objects.",
              setup: () => {
                setSimulationMode("draped");
                setFormMode("sphere");
                setGravity(true, 0.4);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "When cloth interacts with solid objects, collision detection ensures it wraps naturally around the object without penetrating it. Observe how the cloth conforms to the object's shape while still responding to gravity."
            },
            {
              title: "Advanced Collision",
              instructions: "Let's try a more complex form to drape over.",
              setup: () => {
                setSimulationMode("draped");
                setFormMode("cylinder");
                setGravity(true, 0.4);
                setShadingMode("cloth");
                resetCloth();
              },
              explanation: "Different object shapes create different draping patterns. The cylindrical form creates distinct folds and wrinkles as the cloth conforms to its shape while still hanging under gravity."
            }
          ]
        }
      ];
      
      /* Global variables for various systems */
      // Animation system
      let recordingActive = false;
      let recordedFrames = [];
      let playbackActive = false;
      let playbackFrame = 0;
      let playbackInterval = null;
      
      // Guided learning system
      let guidedLearningActive = false;
      let currentStep = 0;
      
      // Animation presets
      let activeAnimationInterval = null;
      
      /* ERROR HANDLING */
      function showError(message) {
        let errorDiv = select('#errorMessage');
        if (!errorDiv) {
          errorDiv = createDiv(message);
          errorDiv.id('errorMessage');
          errorDiv.parent('body');
        } else {
          errorDiv.html(message);
        }
        
        errorDiv.style('display', 'block');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          errorDiv.style('display', 'none');
        }, 5000);
      }
      
      /* PERFORMANCE MONITORING */
      function updatePerformanceMonitor() {
        try {
          const currentTime = millis();
          const elapsedTime = currentTime - lastFrameTime;
          lastFrameTime = currentTime;
          
          if (elapsedTime > 0) {
            const instantFPS = 1000 / elapsedTime;
            frameRateArray.push(instantFPS);
            
            // Keep only the last 30 frames for averaging
            if (frameRateArray.length > 30) {
              frameRateArray.shift();
            }
            
            // Calculate average FPS
            const avgFPS = frameRateArray.reduce((sum, fps) => sum + fps, 0) / frameRateArray.length;
            frameRate = avgFPS;
            
            // Update performance indicator if visible
            if (showPerformanceMetrics) {
              select('#performanceIndicator').html(`FPS: ${frameRate.toFixed(1)} | Points: ${clothPoints.length} | Quality: ${simulationQuality}`);
              select('#performanceIndicator').style('display', 'block');
            }
            
            // Auto-adjust quality if necessary and enabled
            if (adaptiveRendering && frameCount % 30 === 0) {
              adaptQuality(frameRate);
            }
          }
          
          frameCount++;
        } catch (error) {
          console.error("Error updating performance monitor:", error);
        }
      }

      // Improved adaptive quality adjustment
      function adaptQuality(currentFPS) {
        try {
          // Very poor performance - emergency reduction
          if (currentFPS < 10) {
            if (simulationQuality !== "low") {
              setSimulationQuality("low");
              showError("Performance is very low - reducing quality. Check settings tab.");
              
              // Also reduce resolution if it's too high
              if (cols > 20) {
                cols = rows = 15;
                setupCloth();
              }
            }
          }
          // Poor performance - reduce quality
          else if (currentFPS < 20 && simulationQuality !== "low") {
            setSimulationQuality("low");
            showError("Performance is low - reducing quality. Check settings tab.");
          }
          // Average performance - use medium quality
          else if (currentFPS < 35 && simulationQuality === "high") {
            setSimulationQuality("medium");
            // No error message needed for this mild adjustment
          }
          // Good performance - can increase quality if currently low
          else if (currentFPS > 50 && simulationQuality === "low") {
            setSimulationQuality("medium");
          }
          // Excellent performance - can use high quality
          else if (currentFPS > 55 && simulationQuality === "medium") {
            setSimulationQuality("high");
          }
        } catch (error) {
          console.error("Error in adaptive quality adjustment:", error);
        }
      }
      
      /* QUALITY SETTINGS */
      function setSimulationQuality(quality) {
        try {
          const previousQuality = simulationQuality;
          simulationQuality = quality;
          
          // Update radio button if exists
          try {
            const qualityRadios = selectAll('input[name="quality_radio"]');
            for (let r of qualityRadios) {
              if (r.value() === quality) {
                r.checked(true);
              }
            }
          } catch (e) {
            console.error("Could not update quality radio buttons:", e);
          }
          
          // Apply quality settings only if changed
          if (previousQuality !== quality) {
            switch (quality) {
              case "low":
                // Reduce constraint iterations
                if (iterations > 3) {
                  iterations = 3;
                  // Update UI slider if exists
                  try {
                    select("#iterationsVal").html("3");
                  } catch (e) {
                    console.error("Could not update iterations UI:", e);
                  }
                }
                break;
                
              case "medium":
                // Balanced settings
                if (iterations < 3 || iterations > 5) {
                  iterations = 5;
                  // Update UI slider if exists
                  try {
                    select("#iterationsVal").html("5");
                  } catch (e) {
                    console.error("Could not update iterations UI:", e);
                  }
                }
                break;
                
              case "high":
                // No restrictions on settings
                break;
            }
            
            // Clear any cached values that need to be recalculated
            window.cachedMinMaxY = null;
            
            console.log(`Quality changed from ${previousQuality} to ${quality}`);
          }
        } catch (error) {
          console.error("Error setting simulation quality:", error);
        }
      }
      
      // Helper functions for safe array access
      function safeArrayAccess(array, index, defaultValue = null) {
        if (array && index >= 0 && index < array.length) {
          return array[index];
        }
        return defaultValue;
      }
      
      // Check if a grid point is valid
      function isValidGridPoint(y, x) {
        return grid && 
               y >= 0 && y < grid.length && 
               grid[y] && 
               x >= 0 && x < grid[y].length && 
               grid[y][x] !== undefined;
      }
      
      // Recovery function for critical errors
      function recoverFromError() {
        console.log("Recovering from critical error...");
        
        // Reset to safe defaults
        simulationQuality = "low";
        
        // Reduce cloth resolution
        if (cols > 15) {
          cols = rows = 15;
        }
        
        // Disable complex features
        showPerformanceMetrics = true;
        
        // Stop any active animations
        if (activeAnimationInterval) {
          clearInterval(activeAnimationInterval);
          activeAnimationInterval = null;
        }
        
        // Stop recording if active
        if (recordingActive) {
          recordingActive = false;
          select('#recordBtn').html('Start Recording');
        }
        
        // Stop playback if active
        if (playbackActive) {
          playbackActive = false;
          if (playbackInterval) {
            clearInterval(playbackInterval);
            playbackInterval = null;
          }
          select('#playBtn').html('Play Animation');
        }
        
        // Recreate the cloth
        try {
          setupCloth();
        } catch (e) {
          console.error("Could not recover cloth:", e);
          showError("Critical error. Please refresh the page.");
        }
      }
      
      function setup() {
        try {
          let cnv = createCanvas(windowWidth - 280, windowHeight, WEBGL);
          cnv.parent("canvasContainer");
          cnv.style("display", "block");
          
          // Initialize UI and systems
          createUI();
          setupCloth();
          
          // Initialize educational systems
          setupEducationalOverlays();
          setupPhysicsMetrics();
          setupGuidedLearning();
          
          // Create fabric presets
          createMaterialPresets();
          
          // Add explanation triggers
          addExplanationTriggers();
          
          // Setup touch handlers AFTER canvas is created
          setupTouchHandlers();
          
          // Setup performance monitoring
          select('#performanceIndicator').style('display', showPerformanceMetrics ? 'block' : 'none');
          
          // Mobile menu toggle
          select('#menuToggle').mousePressed(() => {
            select('#uiPanel').toggleClass('active');
          });
          
          // Hide loading screen after everything is initialized
          setTimeout(() => {
            select('#loadingOverlay').style('display', 'none');
          }, 1000);
          
        } catch (error) {
          console.error("Error during setup:", error);
          showError("Error initializing the application. Please try refreshing the page.");
        }
      }
      
      function draw() {
        try {
          // Clear background
          background(30);
          
          // Update performance metrics
          updatePerformanceMonitor();
          
          // Handle camera orientation reset
          if (doResetOrientation) {
            camera(0, 0, (height/2) / tan(PI*30/180),
                  0, 0, 0,
                  0, 1, 0);
            doResetOrientation = false;
          }
          
          // Handle camera controls
          if (interactionMode === "rotate" && !playbackActive) {
            orbitControl();
          }
          
          // Set up lighting
          setupLighting();
          
          // Run simulation if active and not in playback mode
          if (simulationRunning && !playbackActive) {
            updateCloth();
          }
          
          // Draw the scene with visualization method based on quality
          if (simulationQuality === "low") {
            // Simpler rendering for low quality
            drawLowQualityScene();
          } else {
            // Normal rendering for medium/high quality
            drawScene();
          }
          
          // Update physics metrics if enabled
          if (select('#physicsMetrics') && select('#physicsMetrics').style('display') === 'block') {
            updatePhysicsMetrics();
          }
          
        } catch (error) {
          console.error("Error in draw loop:", error);
          
          // Only show error if it's not happening continuously
          if (frameCount % 60 === 0) {
            showError("Rendering error encountered. Trying to recover...");
            
            // Attempt to recover
            recoverFromError();
          }
        }
      }
      
      // Simplified scene rendering for low quality mode
      function drawLowQualityScene() {
        // If draped mode, draw the chosen form
        if (simulationMode === "draped") {
          noStroke();
          fill("#333"); // dark grey
          if (formMode === "sphere") {
            push();
            translate(sphereCentre.x, sphereCentre.y, sphereCentre.z);
            sphere(sphereRadius);
            pop();
          } else {
            push();
            let midY = (cylinderTopY + cylinderBottomY)/2;
            translate(0, midY, 0);
            cylinder(cylRadius, cylHeight);
            pop();
          }
        }
        
        // Simplified wireframe rendering
        stroke(255);
        strokeWeight(1);
        noFill();
        
        // Draw only a subset of constraints for better performance
        for (let i = 0; i < clothConstraints.length; i += 2) {
          if (i >= clothConstraints.length) continue;
          let c = clothConstraints[i];
          if (!c) continue;
          
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          
          if (!p1 || !p2) continue;
          
          line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        }
        
        // Skip rendering points to improve performance
      }
      
      // Advanced lighting setup
      function setupLighting() {
        try {
          // Ambient light
          ambientLight(60, 60, 70);
          
          // Main directional light
          directionalLight(255, 255, 255, 0.5, 1, -0.5);
          
          // Point light that follows viewer - only in high quality mode
          if (simulationQuality === "high") {
            let camX = sin(frameCount * 0.01) * 200;
            let camZ = cos(frameCount * 0.01) * 200;
            pointLight(255, 220, 180, camX, -100, camZ);
          }
        } catch (error) {
          console.error("Error in lighting setup:", error);
          // Fallback to basic lighting
          ambientLight(200, 200, 200);
        }
      }
      
      // Separated scene drawing
      function drawScene() {
        // If draped mode, draw the chosen form + invisible floor
        if (simulationMode === "draped") {
          noStroke();
          fill("#333"); // dark grey
          if (formMode === "sphere") {
            push();
            translate(sphereCentre.x, sphereCentre.y, sphereCentre.z);
            sphere(sphereRadius);
            pop();
          } else {
            push();
            let midY = (cylinderTopY + cylinderBottomY)/2;
            translate(0, midY, 0);
            cylinder(cylRadius, cylHeight);
            pop();
          }
          // Draw invisible floor (wireframe)
          push();
          translate(0, floorY, 0);
          noFill();
          stroke(50);
          plane(1000, 1000);
          pop();
        }
        
        // Choose rendering method based on shading mode
        if (shadingMode === "off") {
          renderWireframe();
        } else if (shadingMode === "cloth" || shadingMode === "overlaid") {
          renderShaded();
          if (shadingMode === "overlaid") {
            renderWireframe();
          }
        } else if (shadingMode === "stress") {
          renderStressMap();
        } else if (shadingMode === "structure") {
          renderStructure();
        }
      }
      
      // Original wireframe rendering
      function renderWireframe() {
        stroke(255);
        strokeWeight(2);
        noFill();
        
        // Only draw a subset of constraints in low/medium quality
        const stride = simulationQuality === "high" ? 1 : (simulationQuality === "medium" ? 2 : 3);
        
        for (let i = 0; i < clothConstraints.length; i += stride) {
          if (i >= clothConstraints.length) continue;
          let c = clothConstraints[i];
          if (!c) continue;
          
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          
          if (!p1 || !p2) continue;
          
          line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        }
        
        // Don't render points in low quality mode
        if (simulationQuality !== "low") {
          fill(255);
          noStroke();
          for (let i = 0; i < clothPoints.length; i += stride) {
            if (i >= clothPoints.length) continue;
            let p = clothPoints[i];
            if (!p) continue;
            
            push();
            translate(p.x, p.y, p.z);
            sphere(2);
            pop();
          }
        }
      }
      
      // Optimized shaded rendering with better performance
      function renderShaded() {
        try {
          // Cache min/max Y calculations
          if (!window.cachedMinMaxY || frameCount % 5 === 0) {
            let minY = Infinity, maxY = -Infinity;
            
            // Sample a subset of points for min/max Y for better performance
            const step = simulationQuality === "high" ? 2 : (simulationQuality === "medium" ? 3 : 4);
            
            for (let y = 0; y < rows; y += step) {
              for (let x = 0; x < cols; x += step) {
                if (!isValidGridPoint(y, x)) continue;
                
                let pt = clothPoints[grid[y][x]];
                if (!pt) continue;
                
                if (pt.y < minY) minY = pt.y;
                if (pt.y > maxY) maxY = pt.y;
              }
            }
            
            // Store cached values
            window.cachedMinMaxY = { min: minY, max: maxY };
          }
          
          const minY = window.cachedMinMaxY.min;
          const maxY = window.cachedMinMaxY.max;

          // Enhanced shading with better lighting
          noStroke();
          
          // Only use specular material in high quality mode
          if (simulationQuality === "high") {
            specularMaterial(180);
            shininess(50);
          } else {
            // Use faster materials for lower quality
            ambientMaterial(200);
          }
          
          // Use TRIANGLES for better WebGL performance than individual quads
          beginShape(TRIANGLES);
          
          // Adaptive step size based on quality
          const step = simulationQuality === "high" ? 1 : (simulationQuality === "medium" ? 2 : 3);
          
          for (let y = 0; y < rows - 1; y += step) {
            for (let x = 0; x < cols - 1; x += step) {
              // Skip some cells in low quality mode for better performance
              if (simulationQuality === "low" && (x + y) % 2 !== 0) continue;
              
              // Skip invalid grid cells
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
                  
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x+1];
              let idxD = grid[y+1][x];
              
              // Skip invalid points
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              
              // Color based on height - calculate once per quad
              let avgY = (A.y + B.y + C.y + D.y) * 0.25;
              let hue = map(avgY, minY, maxY, 190, 230);
              let saturation = 20;
              let brightness = map(avgY, minY, maxY, 90, 50);
              
              fill(hue, saturation, brightness);
              
              // Draw first triangle (A-B-C)
              vertex(A.x, A.y, A.z);
              vertex(B.x, B.y, B.z);
              vertex(C.x, C.y, C.z);
              
              // Draw second triangle (A-C-D)
              vertex(A.x, A.y, A.z);
              vertex(C.x, C.y, C.z);
              vertex(D.x, D.y, D.z);
            }
          }
          
          endShape();
        } catch (error) {
          console.error("Error in shaded rendering:", error);
          // Fallback to simple rendering
          background(30);
          renderWireframe();
        }
      }
      
      // Optimized stress map rendering with enhanced colors
      function renderStressMap() {
        try {
          // Check if cellRestArea has been properly initialized
          if (!cellRestArea || cellRestArea.length === 0) {
            console.error("Error: cellRestArea not initialized");
            renderWireframe();
            return;
          }
          
          noStroke();
          let sensitivityFactor = 1.0;
          
          // Use TRIANGLES for better WebGL performance
          beginShape(TRIANGLES);
          
          // Sample fewer cells in low/medium quality
          const step = simulationQuality === "high" ? 1 : (simulationQuality === "medium" ? 2 : 3);
          
          for (let y = 0; y < rows - 1; y += step) {
            for (let x = 0; x < cols - 1; x += step) {
              // Skip some cells in low quality mode
              if (simulationQuality === "low" && (x + y) % 2 !== 0) continue;
              
              // Skip invalid cells
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
                  
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x+1];
              let idxD = grid[y+1][x];
              
              // Skip invalid points
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) continue;
                  
              // Skip if no rest area data
              if (!cellRestArea[y] || cellRestArea[y][x] === undefined) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              
              let currArea = computeQuadArea(A, B, C, D);
              let restArea = cellRestArea[y][x];
              
              // Skip invalid areas
              if (restArea <= 0) continue;
              
              let diff = currArea - restArea;
              let maxDelta = restArea * 1.0 * sensitivityFactor;
              let val = constrain(diff, -maxDelta, maxDelta);
              let ratio = map(val, -maxDelta, maxDelta, 0, 1);
              
              // Enhanced color gradient for stress
              let r, g, b;
              if (ratio < 0.5) {
                // Compression: Blue to White
                let blueRatio = map(ratio, 0, 0.5, 1, 0);
                r = 255 * (1 - blueRatio);
                g = 255 * (1 - blueRatio);
                b = 255;
              } else {
                // Tension: White to Red
                let redRatio = map(ratio, 0.5, 1, 0, 1);
                r = 255;
                g = 255 * (1 - redRatio);
                b = 255 * (1 - redRatio);
              }
              
              fill(r, g, b);
              
              // Draw first triangle (A-B-C)
              vertex(A.x, A.y, A.z);
              vertex(B.x, B.y, B.z);
              vertex(C.x, C.y, C.z);
              
              // Draw second triangle (A-C-D)
              vertex(A.x, A.y, A.z);
              vertex(C.x, C.y, C.z);
              vertex(D.x, D.y, D.z);
            }
          }
          
          endShape();
        } catch (error) {
          console.error("Error in stress rendering:", error);
          // Fallback to wireframe
          renderWireframe();
        }
      }
      
      // Original structure visualization with enhanced colors
      function renderStructure() {
        try {
          // Colour-coded lines by constraint type
          noFill();
          strokeWeight(2);
          
          // Different stride based on quality
          const stride = simulationQuality === "high" ? 1 : (simulationQuality === "medium" ? 2 : 3);
          
          // Draw constraints with different colors based on type
          for (let i = 0; i < clothConstraints.length; i += stride) {
            if (i >= clothConstraints.length) continue;
            let c = clothConstraints[i];
            if (!c) continue;
            
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            if (!p1 || !p2) continue;
            
            if (c.type === STRUCTURAL) {
              stroke(0, 220, 100, 200);
            } else if (c.type === SHEAR) {
              stroke(255, 200, 0, 200);
            } else if (c.type === BENDING) {
              stroke(50, 150, 255, 200);
            } else {
              stroke(255, 255, 255, 200);
            }
            
            line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
          }
          
          // Skip rendering points in low quality mode
          if (simulationQuality !== "low") {
            fill(255, 100, 100);
            noStroke();
            for (let i = 0; i < clothPoints.length; i += stride * 2) {
              if (i >= clothPoints.length) continue;
              let p = clothPoints[i];
              if (!p) continue;
              
              push();
              translate(p.x, p.y, p.z);
              sphere(2);
              pop();
            }
          }
        } catch (error) {
          console.error("Error in structure rendering:", error);
          // Fallback to simpler rendering
          stroke(255);
          noFill();
          for (let i = 0; i < clothConstraints.length; i += 3) {
            if (i >= clothConstraints.length) continue;
            let c = clothConstraints[i];
            if (!c) continue;
            
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            if (!p1 || !p2) continue;
            
            line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
          }
        }
      }

      function createUI() {
        try {
          // Reset Cloth and Reset Orientation buttons
          select("#resetBtn").mousePressed(resetCloth);
          select("#resetOrientationBtn").mousePressed(() => { doResetOrientation = true; });

          // Play/Pause Simulation button
          const playPauseBtn = select("#playPauseBtn");
          playPauseBtn.mousePressed(() => {
            simulationRunning = !simulationRunning;
            playPauseBtn.html(simulationRunning ? "Pause Simulation" : "Play Simulation");
          });

          // Simulation Mode radio
          let simModeRadio = createRadio();
          simModeRadio.option("plane", "Plane");
          simModeRadio.option("draped", "Draped");
          simModeRadio.selected("plane");
          simModeRadio.elt.name = "simulationMode_radio";
          simModeRadio.parent("simModeRadio");
          simModeRadio.changed(() => {
            simulationMode = simModeRadio.value();
            setupCloth();
          });

          // Form Mode radio (only relevant in Draped mode)
          let formModeRadio = createRadio();
          formModeRadio.option("sphere", "Sphere");
          formModeRadio.option("cylinder", "Cylinder");
          formModeRadio.selected("sphere");
          formModeRadio.elt.name = "formMode_radio";
          formModeRadio.parent("formModeRadio");
          formModeRadio.changed(() => {
            formMode = formModeRadio.value();
            if (simulationMode === "draped") setupCloth();
          });

          // Interaction Mode radio
          let interactionRadio = createRadio();
          interactionRadio.option("rotate", "Rotate");
          interactionRadio.option("drag", "Drag");
          interactionRadio.selected("rotate");
          interactionRadio.elt.name = "interaction_radio";
          interactionRadio.parent("interactionRadioGroup");
          interactionRadio.changed(() => {
            interactionMode = interactionRadio.value();
          });

          // Pinning Mode radio (for Plane mode)
          let pinRadio = createRadio();
          pinRadio.option("top", "Top Pinned");
          pinRadio.option("corners", "Corner Pinned");
          pinRadio.selected("top");
          pinRadio.elt.name = "pinning_radio";
          pinRadio.parent("pinningRadio");
          pinRadio.changed(() => {
            pinningMode = pinRadio.value();
            if (simulationMode === "plane") setupCloth();
          });

          // Quality Mode radio
          let qualityRadio = createRadio();
          qualityRadio.option("low", "Low");
          qualityRadio.option("medium", "Medium");
          qualityRadio.option("high", "High");
          qualityRadio.selected("high");
          qualityRadio.elt.name = "quality_radio";
          qualityRadio.parent("qualityRadioGroup");
          qualityRadio.changed(() => {
            simulationQuality = qualityRadio.value();
            // Handle adaptive quality changes
            if (simulationQuality === "high") {
              adaptiveRendering = true;
            } else {
              adaptiveRendering = false;
            }
          });

          // Shading radio => "off", "cloth", "overlaid", "stress", "structure"
          let shadingRadio = createRadio();
          shadingRadio.option("off", "Lines Only");
          shadingRadio.option("cloth", "Solid");
          shadingRadio.option("overlaid", "Overlaid");
          shadingRadio.option("stress", "Stress");
          shadingRadio.option("structure", "Structure");
          shadingRadio.elt.name = "shading_radio";
          shadingRadio.parent("shadingRadioGroup");
          shadingRadio.selected("off");
          shadingRadio.changed(() => {
            shadingMode = shadingRadio.value();
          });
          
          // Cloth resolution slider
          createSliderAndLabel("resolutionSlider", (val) => {
            try {
              // Convert slider value to grid size (10-40)
              let newSize = Math.floor(map(val, 0, 100, 10, 40));
              select("#resolutionVal").html(newSize + "×" + newSize);
              
              if (cols !== newSize || rows !== newSize) {
                cols = rows = newSize;
                spacing = 800 / newSize; // Adjust spacing based on resolution
                setupCloth();
              }
            } catch (error) {
              console.error("Error updating resolution:", error);
            }
          }, 0, 100, 20, 5);

          // Helper to attach param toggles
          function attachParamRadio(parentId, setFlag, containerId) {
            try {
              let r = createRadio();
              r.option("off", "Off");
              r.option("on", "On");
              r.elt.name = parentId + "_radio";
              r.parent(parentId);
              r.selected("off");
              r.changed(() => {
                let val = r.value();
                let on = (val === "on");
                setFlag(on);
                if (containerId) {
                  if (on) select("#" + containerId).style("display", "block");
                  else select("#" + containerId).style("display", "none");
                }
              });
            } catch (error) {
              console.error(`Error creating radio for ${parentId}:`, error);
            }
          }

          // Attach toggles for each parameter
          attachParamRadio("dampingRadioGroup", (on) => { dampingOn = on; }, "dampingContainer");
          attachParamRadio("iterationsRadioGroup", (on) => { iterationsOn = on; }, "iterationsContainer");
          attachParamRadio("stretchRadioGroup", (on) => { stretchOn = on; }, "stretchContainer");
          attachParamRadio("shearRadioGroup", (on) => { shearOn = on; }, "shearContainer");
          attachParamRadio("bendingRadioGroup", (on) => { bendingOn = on; }, "bendingContainer");
          attachParamRadio("weightRadioGroup", (on) => { weightOn = on; }, "weightContainer");
          attachParamRadio("windXRadioGroup", (on) => { windXOn = on; }, "windXContainer");
          attachParamRadio("windYRadioGroup", (on) => { windYOn = on; }, "windYContainer");
          attachParamRadio("windZRadioGroup", (on) => { windZOn = on; }, "windZContainer");
          attachParamRadio("windBufRadioGroup", (on) => { windBufOn = on; }, "windBufContainer");
          attachParamRadio("gravityRadioGroup", (on) => { gravityOn = on; }, "gravityContainer");

          // Helper: Create slider
          function createSliderAndLabel(divId, callback, min, max, val, step) {
            try {
              const slider = createSlider(min, max, val, step);
              slider.parent(divId);
              slider.input(() => { callback(slider.value()); });
              callback(slider.value());
            } catch (error) {
              console.error(`Error creating slider for ${divId}:`, error);
            }
          }

          // Sliders
          createSliderAndLabel("dampingSlider", (val) => {
            damping = val;
            select("#dampingVal").html(nf(val, 1, 2));
          }, 0.90, 1.0, 0.98, 0.01);

          createSliderAndLabel("iterationsSlider", (val) => {
            iterations = val;
            select("#iterationsVal").html(val);
          }, 1, 10, 5, 1);

          createSliderAndLabel("stretchSlider", (val) => {
            stretchFactor = val;
            select("#stretchVal").html(nf(val, 1, 2));
          }, 0.8, 1.2, 1.0, 0.01);

          createSliderAndLabel("shearSlider", (val) => {
            shearFactor = val;
            select("#shearVal").html(nf(val, 1, 2));
          }, 0.8, 1.2, 1.0, 0.01);

          createSliderAndLabel("bendingSlider", (val) => {
            bendingFactor = val;
            select("#bendingVal").html(nf(val, 1, 2));
          }, 0.8, 1.2, 1.0, 0.01);

          createSliderAndLabel("weightSlider", (val) => {
            weight = val;
            select("#weightVal").html(nf(val, 1, 2));
          }, 0.5, 2.0, 1.0, 0.1);

          createSliderAndLabel("windXSlider", (val) => {
            windX = val;
            select("#windXVal").html(nf(val, 1, 2));
          }, -1, 1, 0.2, 0.01);

          createSliderAndLabel("windYSlider", (val) => {
            windY = val;
            select("#windYVal").html(nf(val, 1, 2));
          }, -1, 1, 0, 0.01);

          createSliderAndLabel("windZSlider", (val) => {
            windZ = val;
            select("#windZVal").html(nf(val, 1, 2));
          }, -1, 1, 0.1, 0.01);

          createSliderAndLabel("windBufSlider", (val) => {
            windBuffer = val;
            select("#windBufVal").html(nf(val, 1, 2));
          }, 0, 2, 1.0, 0.01);

          createSliderAndLabel("gravitySlider", (val) => {
            gravity = val;
            select("#gravityVal").html(nf(val, 1, 2));
          }, 0, 1, 0.4, 0.01);
          
          // Tab Navigation
          document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
              document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
              document.querySelectorAll('.tabContent').forEach(c => c.classList.remove('active'));
              
              this.classList.add('active');
              document.getElementById(this.getAttribute('onclick').match(/'([^']+)'/)[1]).classList.add('active');
            });
          });
          
          // Educational overlays button
          select("#showExplanationsBtn").mousePressed(toggleOverlay);
          
          // Physics metrics button
          select("#showPhysicsBtn").mousePressed(togglePhysicsPanel);
          
          // Guided learning button
          select("#startLearningBtn").mousePressed(toggleGuidedLearning);
          
          // Real comparison button
          select("#showComparisonBtn").mousePressed(toggleComparisonView);
          
          // Animation preset dropdown
          select("#animationPresetSelect").changed(function() {
            let selected = this.value();
            if (selected) {
              applyAnimationPreset(selected);
            }
          });
          
          // Recording buttons
          select("#recordBtn").mousePressed(toggleRecording);
          select("#playBtn").mousePressed(togglePlayback);
          select("#timelapseBtn").mousePressed(createTimelapse);
        } catch (error) {
          console.error("Error creating UI:", error);
          showError("Error setting up the interface. Please refresh the page.");
        }
      }
      
      function createMaterialPresets() {
        try {
          // Create material preset cards
          let container = select("#materialPresetCards");
          
          // Add custom card
          let customCard = createDiv();
          customCard.class('materialCard active');
          customCard.attribute('data-preset', 'custom');
          customCard.parent(container);
          
          let customName = createDiv('Custom Settings');
          customName.class('materialName');
          customName.parent(customCard);
          
          let customDesc = createDiv('Your own parameter configuration');
          customDesc.class('materialDesc');
          customDesc.parent(customCard);
          
          customCard.mousePressed(() => selectMaterialPreset('custom'));
          
          // Add preset cards
          for (let key in FABRIC_PRESETS) {
            let card = createDiv();
            card.class('materialCard');
            card.attribute('data-preset', key);
            card.parent(container);
            
            let name = createDiv(FABRIC_PRESETS[key].name);
            name.class('materialName');
            name.parent(card);
            
            let desc = createDiv(FABRIC_PRESETS[key].properties.description);
            desc.class('materialDesc');
            desc.parent(card);
            
            card.mousePressed(() => selectMaterialPreset(key));
          }
        } catch (error) {
          console.error("Error creating material presets:", error);
        }
      }
      
      function selectMaterialPreset(preset) {
        try {
          // Update UI
          document.querySelectorAll('.materialCard').forEach(card => {
            card.classList.remove('active');
            if (card.getAttribute('data-preset') === preset) {
              card.classList.add('active');
            }
          });
          
          // Apply preset
          applyFabricPreset(preset);
        } catch (error) {
          console.error("Error selecting material preset:", error);
        }
      }
      
      /* Setup cloth based on simulation mode */
      function setupCloth() {
        try {
          clothPoints = [];
          clothConstraints = [];
          grid = [];
          horizontal = [];
          vertical = [];
          centers = [];
          cellRestArea = [];

          let clothWidth = (cols - 1) * spacing;
          let clothHeight = (rows - 1) * spacing;

          if (simulationMode === "plane") {
            let startX = -clothWidth/2 + clothShiftX;
            let startY = -clothHeight/2;
            createClothPoints_Plane(startX, startY, 0);

          } else {
            // Draped mode
            if (formMode === "sphere") {
              sphereCentre = { x: 0, y: 0, z: 0 };
              sphereRadius = 100;
              let startY = -sphereRadius;
              createClothPoints_Draped(-clothWidth/2, startY, -clothHeight/2);

              // Pin centre cloth point to top of sphere
              let midRow = Math.floor(rows/2);
              let midCol = Math.floor(cols/2);
              let centerIdx = grid[midRow][midCol];
              clothPoints[centerIdx].pinned = true;
              clothPoints[centerIdx].x = sphereCentre.x;
              clothPoints[centerIdx].y = sphereCentre.y - sphereRadius;
              clothPoints[centerIdx].z = sphereCentre.z;
              clothPoints[centerIdx].oldx = sphereCentre.x;
              clothPoints[centerIdx].oldy = sphereCentre.y - sphereRadius;
              clothPoints[centerIdx].oldz = sphereCentre.z;

            } else if (formMode === "cylinder") {
              let startY = cylinderTopY;
              createClothPoints_Draped(-clothWidth/2, startY, -clothHeight/2);

              // Pin centre cloth point at cylinder's top centre
              let midRow = Math.floor(rows/2);
              let midCol = Math.floor(cols/2);
              let centerIdx = grid[midRow][midCol];
              clothPoints[centerIdx].pinned = true;
              clothPoints[centerIdx].x = 0;
              clothPoints[centerIdx].y = cylinderTopY;
              clothPoints[centerIdx].z = 0;
              clothPoints[centerIdx].oldx = 0;
              clothPoints[centerIdx].oldy = cylinderTopY;
              clothPoints[centerIdx].oldz = 0;
            }
          }

          // Override floor if needed
          if (simulationMode === "draped") {
            if (formMode === "sphere") {
              floorY = 150;
            } else if (formMode === "cylinder") {
              floorY = cylinderBottomY;
            }
          } else {
            floorY = 150;
          }

          // Initialize cellRestArea
          // This must be done BEFORE creating additional points and constraints
          // to ensure it's always initialized for all quality settings
          initializeCellRestArea();
          
          // Then create additional points and constraints
          createSubPointsAndConstraints();
          
          // Update performance indicator
          if (showPerformanceMetrics) {
            select('#performanceIndicator').html(`Points: ${clothPoints.length} | Constraints: ${clothConstraints.length}`);
          }
        } catch (error) {
          console.error("Error setting up cloth:", error);
          showError("Error creating cloth structure. Please try a lower resolution.");
        }
      }
      
      // Helper function to reset the cloth
      function resetCloth() {
        setupCloth();
      }
      
      // New function to properly initialize cell rest areas
      function initializeCellRestArea() {
        try {
          cellRestArea = [];
          for (let y = 0; y < rows - 1; y++) {
            cellRestArea[y] = [];
            for (let x = 0; x < cols - 1; x++) {
              // Skip invalid grid cells
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
                  
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              // Skip invalid points
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              
              let restArea = computeQuadArea(A, B, C, D);
              cellRestArea[y][x] = restArea > 0 ? restArea : spacing * spacing;
            }
          }
        } catch (error) {
          console.error("Error initializing cell rest area:", error);
        }
      }

      function createClothPoints_Plane(startX, startY, startZ) {
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            let px = startX + x * spacing;
            let py = startY + y * spacing;
            let pz = startZ;
            let pinned = false;
            if (pinningMode === "top") {
              pinned = (y === 0);
            } else if (pinningMode === "corners") {
              pinned = (
                (x === 0 && y === 0) ||
                (x === cols-1 && y === 0) ||
                (x === 0 && y === rows-1) ||
                (x === cols-1 && y === rows-1)
              );
            }
            clothPoints.push({
              x: px, y: py, z: pz,
              oldx: px, oldy: py, oldz: pz,
              pinned: pinned
            });
            grid[y][x] = clothPoints.length - 1;
          }
        }
      }

      function createClothPoints_Draped(startX, fixedY, startZ) {
        for (let rz = 0; rz < rows; rz++) {
          grid[rz] = [];
          for (let cx = 0; cx < cols; cx++) {
            let px = startX + cx * spacing;
            let py = fixedY;
            let pz = startZ + rz * spacing;
            clothPoints.push({
              x: px, y: py, z: pz,
              oldx: px, oldy: py, oldz: pz,
              pinned: false
            });
            grid[rz][cx] = clothPoints.length - 1;
          }
        }
      }

      function createSubPointsAndConstraints() {
        // Optimize for lower quality
        const createDetailedMesh = simulationQuality !== "low";
        
        if (createDetailedMesh) {
          // Create horizontal midpoints
          horizontal = [];
          for (let y = 0; y < rows; y++) {
            horizontal[y] = [];
            for (let x = 0; x < cols - 1; x++) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1)) continue;
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              
              if (!clothPoints[idxA] || !clothPoints[idxB]) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let mx = (A.x + B.x) * 0.5;
              let my = (A.y + B.y) * 0.5;
              let mz = (A.z + B.z) * 0.5;
              clothPoints.push({
                x: mx, y: my, z: mz,
                oldx: mx, oldy: my, oldz: mz,
                pinned: false
              });
              horizontal[y][x] = clothPoints.length - 1;
            }
          }
          
          // Create vertical midpoints
          vertical = [];
          for (let y = 0; y < rows - 1; y++) {
            vertical[y] = [];
            for (let x = 0; x < cols; x++) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y+1, x)) continue;
              
              let idxA = grid[y][x];
              let idxB = grid[y+1][x];
              
              if (!clothPoints[idxA] || !clothPoints[idxB]) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let mx = (A.x + B.x) * 0.5;
              let my = (A.y + B.y) * 0.5;
              let mz = (A.z + B.z) * 0.5;
              clothPoints.push({
                x: mx, y: my, z: mz,
                oldx: mx, oldy: my, oldz: mz,
                pinned: false
              });
              vertical[y][x] = clothPoints.length - 1;
            }
          }
          
          // Create center points
          centers = [];
          for (let y = 0; y < rows - 1; y++) {
            centers[y] = [];
            for (let x = 0; x < cols - 1; x++) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) continue;
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              let mx = (A.x + B.x + C.x + D.x) * 0.25;
              let my = (A.y + B.y + C.y + D.y) * 0.25;
              let mz = (A.z + B.z + C.z + D.z) * 0.25;
              clothPoints.push({
                x: mx, y: my, z: mz,
                oldx: mx, oldy: my, oldz: mz,
                pinned: false
              });
              centers[y][x] = clothPoints.length - 1;
            }
          }
        }
        
        createConstraints(createDetailedMesh);
      }

      function computeQuadArea(A, B, C, D) {
        try {
          let area1 = triArea(A, B, C);
          let area2 = triArea(B, C, D);
          return area1 + area2;
        } catch (error) {
          console.error("Error computing quad area:", error);
          return 1.0; // Return a default value to prevent further errors
        }
      }
      
      function triArea(p1, p2, p3) {
        try {
          let ux = p2.x - p1.x;
          let uy = p2.y - p1.y;
          let uz = p2.z - p1.z;
          let vx = p3.x - p1.x;
          let vy = p3.y - p1.y;
          let vz = p3.z - p1.z;
          let cx = uy * vz - uz * vy;
          let cy = uz * vx - ux * vz;
          let cz = ux * vy - uy * vx;
          return 0.5 * Math.sqrt(cx*cx + cy*cy + cz*cz);
        } catch (error) {
          console.error("Error computing triangle area:", error);
          return 0.5; // Return a default value to prevent further errors
        }
      }

      function createConstraints(createDetailedMesh) {
        try {
          // Structural
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (!isValidGridPoint(y, x)) continue;
              
              let idx = grid[y][x];
              
              if (x < cols - 1 && isValidGridPoint(y, x+1)) {
                addConstraint(idx, grid[y][x+1],
                  spacing * (stretchOn ? stretchFactor : BASE_STRETCH),
                  STRUCTURAL
                );
              }
              
              if (y < rows - 1 && isValidGridPoint(y+1, x)) {
                addConstraint(idx, grid[y+1][x],
                  spacing * (stretchOn ? stretchFactor : BASE_STRETCH),
                  STRUCTURAL
                );
              }
            }
          }
          
          // Bending - reduce density for low quality
          const bendingStep = simulationQuality === "low" ? 2 : 1;
          for (let y = 0; y < rows; y += bendingStep) {
            for (let x = 0; x < cols - 2; x += bendingStep) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+2)) continue;
              
              addConstraint(grid[y][x], grid[y][x+2],
                spacing * 2 * (bendingOn ? bendingFactor : BASE_BENDING),
                BENDING
              );
            }
          }
          
          for (let y = 0; y < rows - 2; y += bendingStep) {
            for (let x = 0; x < cols; x += bendingStep) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y+2, x)) continue;
              
              addConstraint(grid[y][x], grid[y+2][x],
                spacing * 2 * (bendingOn ? bendingFactor : BASE_BENDING),
                BENDING
              );
            }
          }
          
          // Shear
          for (let y = 0; y < rows - 1; y++) {
            for (let x = 0; x < cols - 1; x++) {
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              addConstraint(idxA, idxD,
                Math.sqrt(2) * spacing * (shearOn ? shearFactor : BASE_SHEAR),
                SHEAR
              );
              
              addConstraint(idxB, idxC,
                Math.sqrt(2) * spacing * (shearOn ? shearFactor : BASE_SHEAR),
                SHEAR
              );
            }
          }
          
          // Add detailed constraints only for high/medium quality
          if (createDetailedMesh && simulationQuality !== "low") {
            // Skip this in low quality
            for (let y = 0; y < rows - 1; y++) {
              for (let x = 0; x < cols - 1; x++) {
                if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                    !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) continue;
                
                if (!horizontal[y] || !horizontal[y][x] || 
                    !horizontal[y+1] || !horizontal[y+1][x] ||
                    !vertical[y] || !vertical[y][x] || 
                    !vertical[y][x+1] || !centers[y] || !centers[y][x]) continue;
                
                let A = grid[y][x];
                let B = grid[y][x+1];
                let C = grid[y+1][x];
                let D = grid[y+1][x+1];
                let E = horizontal[y][x];
                let F = horizontal[y+1][x];
                let G = vertical[y][x];
                let H = vertical[y][x+1];
                let I = centers[y][x];
                
                addTriConstraints(A, E, I);
                addTriConstraints(A, G, I);
                addTriConstraints(B, E, I);
                addTriConstraints(B, H, I);
                addTriConstraints(C, G, I);
                addTriConstraints(C, F, I);
                addTriConstraints(D, H, I);
                addTriConstraints(D, F, I);
              }
            }
          }
        } catch (error) {
          console.error("Error creating constraints:", error);
          showError("Error creating cloth constraints. Please try a lower resolution or quality setting.");
        }
      }

      function addTriConstraints(i1, i2, i3) {
        try {
          if (!clothPoints[i1] || !clothPoints[i2] || !clothPoints[i3]) return;
          
          let dist1 = distBetween(i1, i2);
          let dist2 = distBetween(i2, i3);
          let dist3 = distBetween(i3, i1);
          
          if (dist1 <= 0 || dist2 <= 0 || dist3 <= 0) return;
          
          addConstraint(i1, i2, dist1, STRUCTURAL);
          addConstraint(i2, i3, dist2, STRUCTURAL);
          addConstraint(i3, i1, dist3, STRUCTURAL);
        } catch (error) {
          console.error("Error adding triangle constraints:", error);
        }
      }

      function addConstraint(i, j, len, type) {
        try {
          if (i === undefined || j === undefined || i === j || len <= 0) return;
          
          let a = Math.min(i, j);
          let b = Math.max(i, j);
          
          // Check if constraint already exists
          for (let c of clothConstraints) {
            if (c.p1 === a && c.p2 === b) return;
          }
          
          clothConstraints.push({ p1: a, p2: b, length: len, type });
        } catch (error) {
          console.error("Error adding constraint:", error);
        }
      }

      function distBetween(i1, i2) {
        try {
          let p1 = clothPoints[i1];
          let p2 = clothPoints[i2];
          
          if (!p1 || !p2) {
            console.error("Invalid indices for distBetween:", i1, i2);
            return spacing; // Return default spacing as fallback
          }
          
          let dx = p2.x - p1.x;
          let dy = p2.y - p1.y;
          let dz = p2.z - p1.z;
          return Math.sqrt(dx*dx + dy*dy + dz*dz);
        } catch (error) {
          console.error("Error calculating distance:", error);
          return spacing; // Return a default value
        }
      }

      function updateCloth() {
        try {
          let freq = 0.01;
          
          // Skip some points in low quality mode
          const step = simulationQuality === "low" ? 2 : 1;
          
          // Process points - apply forces and integration
          for (let i = 0; i < clothPoints.length; i += step) {
            let p = clothPoints[i];
            if (!p || p.pinned) continue;
            
            let vx = (p.x - p.oldx) * (dampingOn ? damping : BASE_DAMPING);
            let vy = (p.y - p.oldy) * (dampingOn ? damping : BASE_DAMPING);
            let vz = (p.z - p.oldz) * (dampingOn ? damping : BASE_DAMPING);
            p.oldx = p.x;
            p.oldy = p.y;
            p.oldz = p.z;

            // Precompute wind effect based on frame
            let sinVal = Math.sin(frameCount * freq);
            let effectiveWindX = windXOn ? windBuffer * windX * sinVal : BASE_WINDX;
            let effectiveWindY = windYOn ? windBuffer * windY * sinVal : BASE_WINDY;
            let effectiveWindZ = windZOn ? windBuffer * windZ * sinVal : BASE_WINDZ;

            let effGrav = gravityOn ? gravity : BASE_GRAVITY;
            let effWeight = weightOn ? weight : BASE_WEIGHT;

            p.x += vx + effectiveWindX;
            p.y += vy + effGrav * effWeight + effectiveWindY;
            p.z += vz + effectiveWindZ;
          }

          // Apply constraints with different iteration counts based on quality
          let effIter = iterationsOn ? iterations : BASE_ITERATIONS;
          // For low quality, reduce iterations
          if (simulationQuality === "low") effIter = Math.max(1, Math.floor(effIter / 2));
          
          // Fast constraint solver that processes constraints in batches
          for (let iter = 0; iter < effIter; iter++) {
            // Process constraints in smaller chunks for better performance
            // and to avoid blocking the UI thread for too long
            const batchSize = 500; // Process 500 constraints at a time
            
            for (let batchStart = 0; batchStart < clothConstraints.length; batchStart += batchSize) {
              const batchEnd = Math.min(batchStart + batchSize, clothConstraints.length);
              
              for (let j = batchStart; j < batchEnd; j++) {
                if (j >= clothConstraints.length) continue;
                
                let c = clothConstraints[j];
                if (!c) continue;
                
                let p1 = clothPoints[c.p1];
                let p2 = clothPoints[c.p2];
                
                if (!p1 || !p2) continue;
                
                // Skip if both points are pinned (no need to calculate)
                if (p1.pinned && p2.pinned) continue;
                
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                let dz = p2.z - p1.z;
                let distSq = dx*dx + dy*dy + dz*dz;
                
                // Early skip if points are at almost exactly the right distance
                const epsilon = 0.000001;
                const targetDistSq = c.length * c.length;
                if (Math.abs(distSq - targetDistSq) < epsilon) continue;
                
                let distVal = Math.sqrt(distSq);
                
                // Avoid division by zero
                if (distVal > 0.0001) {
                  let diff = (distVal - c.length) / distVal;
                  
                  // Apply constraint based on whether points are pinned
                  if (!p1.pinned && !p2.pinned) {
                    p1.x += dx * 0.5 * diff;
                    p1.y += dy * 0.5 * diff;
                    p1.z += dz * 0.5 * diff;
                    
                    p2.x -= dx * 0.5 * diff;
                    p2.y -= dy * 0.5 * diff;
                    p2.z -= dz * 0.5 * diff;
                  } else if (!p1.pinned) {
                    p1.x += dx * diff;
                    p1.y += dy * diff;
                    p1.z += dz * diff;
                  } else if (!p2.pinned) {
                    p2.x -= dx * diff;
                    p2.y -= dy * diff;
                    p2.z -= dz * diff;
                  }
                }
              }
            }
          }

          // Handle collisions (optimized)
          if (simulationQuality !== "low") {
            doSelfCollision();
          }
          
          if (simulationMode === "draped") {
            if (formMode === "sphere") {
              doSphereCollision();
            } else if (formMode === "cylinder") {
              doCylinderCollision();
            }
            doFloorCollision();
          }
        } catch (error) {
          console.error("Error in cloth simulation:", error);
        }
      }

      function doSelfCollision() {
        try {
          // Skip self-collision for low quality mode
          if (simulationQuality === "low") return;
          
          const threshold = spacing * 0.5;
          const gridSize = threshold * 2;
          const grid = new Map();
          
          // Add points to spatial grid
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid points
            if (!p) continue;
            
            // Calculate grid cell coordinates
            const gx = Math.floor(p.x / gridSize);
            const gy = Math.floor(p.y / gridSize);
            const gz = Math.floor(p.z / gridSize);
            const key = `${gx},${gy},${gz}`;
            
            // Add point to grid
            if (!grid.has(key)) {
              grid.set(key, []);
            }
            grid.get(key).push(i);
          }
          
          // Check nearby cells for collisions
          for (let i = 0; i < clothPoints.length; i++) {
            let p1 = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p1 || p1.pinned) continue;
            
            const gx = Math.floor(p1.x / gridSize);
            const gy = Math.floor(p1.y / gridSize);
            const gz = Math.floor(p1.z / gridSize);
            
            // Check current and neighboring cells
            for (let dx = -1; dx <= 1; dx++) {
              for (let dy = -1; dy <= 1; dy++) {
                for (let dz = -1; dz <= 1; dz++) {
                  const key = `${gx+dx},${gy+dy},${gz+dz}`;
                  const cell = grid.get(key);
                  
                  if (!cell) continue;
                  
                  // Check against points in cell
                  for (let j of cell) {
                    // Skip self or already processed pairs
                    if (j <= i) continue;
                    
                    let p2 = clothPoints[j];
                    
                    // Skip invalid or pinned points
                    if (!p2 || p2.pinned) continue;
                    
                    let dx = p2.x - p1.x;
                    let dy = p2.y - p1.y;
                    let dz = p2.z - p1.z;
                    let d = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (d < threshold && d > 0.0001) { // Avoid very small distances
                      let overlap = threshold - d;
                      let nx = dx / d;
                      let ny = dy / d;
                      let nz = dz / d;
                      
                      p1.x -= nx * overlap * 0.5;
                      p1.y -= ny * overlap * 0.5;
                      p1.z -= nz * overlap * 0.5;
                      p2.x += nx * overlap * 0.5;
                      p2.y += ny * overlap * 0.5;
                      p2.z += nz * overlap * 0.5;
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error("Error in self-collision:", error);
        }
      }

      // Fixed sphere collision function
      function doSphereCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            let dx = p.x - sphereCentre.x;
            let dy = p.y - sphereCentre.y;
            let dz = p.z - sphereCentre.z;
            let distSq = dx*dx + dy*dy + dz*dz;
            let radiusSq = sphereRadius * sphereRadius;
            
            // Early optimization - check squared distance first
            if (distSq >= radiusSq) continue;
            
            let distVal = Math.sqrt(distSq);
            
            // Avoid division by zero
            if (distVal < 0.0001) {
              // Point is very close to center, push it out in a random direction
              let angle = Math.random() * Math.PI * 2;
              dx = Math.cos(angle);
              dy = Math.sin(angle);
              dz = Math.random() - 0.5;
              
              // Normalize
              let len = Math.sqrt(dx*dx + dy*dy + dz*dz);
              dx /= len;
              dy /= len;
              dz /= len;
              
              distVal = 0.0001;
            }
            
            let overlap = sphereRadius - distVal;
            let nx = dx / distVal;
            let ny = dy / distVal;
            let nz = dz / distVal;
            
            // Push point to surface of sphere
            p.x += nx * overlap * (1 + 0.01); // Add small buffer to prevent flicker
            p.y += ny * overlap * (1 + 0.01);
            p.z += nz * overlap * (1 + 0.01);
            
            // Apply friction to reduce sliding
            p.oldx = p.x - collisionFriction * (p.x - p.oldx);
            p.oldy = p.y - collisionFriction * (p.y - p.oldy);
            p.oldz = p.z - collisionFriction * (p.z - p.oldz);
          }
        } catch (error) {
          console.error("Error in sphere collision:", error);
        }
      }

      // Fixed cylinder collision function
      function doCylinderCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            // Only check points that are within the cylinder's height range
            if (p.y > cylinderTopY && p.y < cylinderBottomY) {
              // Calculate distance to cylinder axis (which is along Y)
              let dx = p.x;
              let dz = p.z;
              let r = Math.sqrt(dx*dx + dz*dz);
              
              if (r < cylRadius) {
                let overlap = cylRadius - r;
                
                // Avoid division by zero
                if (r < 0.0001) {
                  // Point is very close to axis, push it out in a random XZ direction
                  let angle = Math.random() * Math.PI * 2;
                  dx = Math.cos(angle);
                  dz = Math.sin(angle);
                  r = 0.0001;
                } else {
                  dx /= r;
                  dz /= r;
                }
                
                // Push point to surface of cylinder
                p.x += dx * overlap * (1 + 0.01); // Add small buffer to prevent flicker
                p.z += dz * overlap * (1 + 0.01);
                
                // Apply friction to reduce sliding
                p.oldx = p.x - collisionFriction * (p.x - p.oldx);
                p.oldz = p.z - collisionFriction * (p.z - p.oldz);
              }
            }
            
            // Also check cylinder caps (top and bottom circles)
            if (p.y < cylinderTopY && p.y > cylinderTopY - cylRadius) {
              // Distance to top cap center
              let dx = p.x;
              let dy = p.y - cylinderTopY;
              let dz = p.z;
              let dxz = Math.sqrt(dx*dx + dz*dz);
              
              // If inside the top cap and below the sphere created by the cap edge
              if (dxz < cylRadius) {
                let capY = cylinderTopY;
                
                // Check if point is inside the cap's spherical region
                let distToEdge = Math.sqrt(Math.pow(cylRadius - dxz, 2) + dy*dy);
                if (distToEdge < cylRadius) {
                  // Push point to cap surface
                  p.y = cylinderTopY;
                  p.oldy = p.y - collisionFriction * (p.y - p.oldy);
                }
              }
            }
            
            // Check bottom cap similarly
            if (p.y > cylinderBottomY && p.y < cylinderBottomY + cylRadius) {
              let dx = p.x;
              let dy = p.y - cylinderBottomY;
              let dz = p.z;
              let dxz = Math.sqrt(dx*dx + dz*dz);
              
              if (dxz < cylRadius) {
                let capY = cylinderBottomY;
                
                let distToEdge = Math.sqrt(Math.pow(cylRadius - dxz, 2) + dy*dy);
                if (distToEdge < cylRadius) {
                  p.y = cylinderBottomY;
                  p.oldy = p.y - collisionFriction * (p.y - p.oldy);
                }
              }
            }
          }
        } catch (error) {
          console.error("Error in cylinder collision:", error);
        }
      }

      // Improved floor collision
      function doFloorCollision() {
        try {
          const collisionFriction = 0.5;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            
            // Skip invalid or pinned points
            if (!p || p.pinned) continue;
            
            if (p.y > floorY) {
              // Store vertical velocity for friction calculation
              let vy = p.y - p.oldy;
              
              // Collide with floor
              p.y = floorY;
              
              // Apply friction scaled by impact velocity
              let friction = Math.min(collisionFriction * (1 + Math.abs(vy) * 2), 0.95);
              
              // Apply horizontal friction based on impact velocity
              p.oldx = p.x - (p.x - p.oldx) * friction;
              p.oldz = p.z - (p.z - p.oldz) * friction;
              
              // Apply slight bounce if velocity was high
              if (vy > 1.0) {
                p.oldy = p.y + vy * -0.2; // 20% bounce
              } else {
                p.oldy = p.y;
              }
            }
          }
        } catch (error) {
          console.error("Error in floor collision:", error);
        }
      }

      /* Improved Touch Event Handlers */
      function setupTouchHandlers() {
        try {
          const canvas = document.getElementById('defaultCanvas0');
          if (!canvas) {
            console.error("Canvas not found for touch setup");
            return;
          }
          
          // Touch start event
          canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length > 0) {
              e.preventDefault(); // Prevent scrolling
              
              // Convert touch coordinates to canvas coordinates
              const canvasRect = canvas.getBoundingClientRect();
              const touchX = e.touches[0].clientX - canvasRect.left;
              const touchY = e.touches[0].clientY - canvasRect.top;
              
              // Update p5.js mouseX and mouseY
              mouseX = touchX;
              mouseY = touchY;
              
              // Call the mousePressed function
              mousePressed();
            }
          }, { passive: false });
          
          // Touch move event
          canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length > 0) {
              e.preventDefault(); // Prevent scrolling when interacting with cloth
              
              // Convert touch coordinates to canvas coordinates
              const canvasRect = canvas.getBoundingClientRect();
              const touchX = e.touches[0].clientX - canvasRect.left;
              const touchY = e.touches[0].clientY - canvasRect.top;
              
              // Update p5.js mouseX and mouseY
              mouseX = touchX;
              mouseY = touchY;
              
              // Call the mouseDragged function
              mouseDragged();
            }
          }, { passive: false });
          
          // Touch end event
          canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            mouseReleased();
          }, { passive: false });
          
          // Touch cancel event
          canvas.addEventListener('touchcancel', function(e) {
            e.preventDefault();
            mouseReleased();
          }, { passive: false });
          
          console.log("Touch handlers initialized successfully");
        } catch (error) {
          console.error("Error setting up touch handlers:", error);
        }
      }

      /* 3D Dragging */
      function mousePressed() {
        try {
          if (interactionMode === "drag") {
            let closest = null;
            let closestDist = 20; // Increased for better mobile/touch interaction
            
            // Find closest point to mouse
            for (let i = 0; i < clothPoints.length; i++) {
              let p = clothPoints[i];
              
              // Skip invalid points
              if (!p) continue;
              
              let sx = modelX(p.x, p.y, p.z);
              let sy = modelY(p.x, p.y, p.z);
              let d = dist(mouseX, mouseY, sx, sy);
              
              if (d < closestDist) {
                closestDist = d;
                closest = i;
              }
            }
            
            if (closest !== null) {
              dragPointIndex = closest;
              dragPlaneZ = clothPoints[closest].z;
            }
          }
        } catch (error) {
          console.error("Error in mouse press handling:", error);
        }
        return false; // Prevent default
      }

      function unproject(mx, my, fixedZ) {
        try {
          let d = (height/2) / tan(PI*30/180);
          let nx = mx - width/2;
          let ny = my - height/2;
          let factor = (d + fixedZ) / d;
          let wx = nx * factor;
          let wy = ny * factor;
          return createVector(wx, wy, fixedZ);
        } catch (error) {
          console.error("Error in unprojection:", error);
          return createVector(0, 0, fixedZ); // Return a default vector
        }
      }

      function mouseDragged() {
        try {
          if (interactionMode === "drag" && dragPointIndex !== null) {
            let p = clothPoints[dragPointIndex];
            
            // Skip invalid points
            if (!p) return false;
            
            let newPos = unproject(mouseX, mouseY, dragPlaneZ);
            p.x = newPos.x;
            p.y = newPos.y;
            p.oldx = newPos.x;
            p.oldy = newPos.y;
          }
        } catch (error) {
          console.error("Error in mouse drag handling:", error);
        }
        return false; // Prevent default
      }

      function mouseReleased() {
        dragPointIndex = null;
        return false; // Prevent default
      }
      
      function windowResized() {
        try {
          // Get current canvas position
          let container = select('#canvasContainer');
          let width = container.width;
          let height = container.height;
          
          // Resize canvas
          resizeCanvas(width, height);
          
          // Reset camera if orientation was reset
          if (doResetOrientation) {
            camera(0, 0, (height/2) / tan(PI*30/180),
                  0, 0, 0,
                  0, 1, 0);
            doResetOrientation = false;
          }
          
          // Handle mobile UI
          if (windowWidth <= 768) {
            select('#uiPanel').removeClass('active');
          }
        } catch (error) {
          console.error("Error in window resize:", error);
        }
      }
      
      /* Tab Navigation */
      function showTab(tabId) {
        try {
          // Hide all tab contents
          document.querySelectorAll('.tabContent').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Deactivate all tabs
          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Show selected tab content
          document.getElementById(tabId).classList.add('active');
          
          // Activate selected tab
          document.querySelector(`[onclick="showTab('${tabId}')"]`).classList.add('active');
        } catch (error) {
          console.error("Error switching tabs:", error);
        }
      }
      
      /* Fabric Presets */
      function applyFabricPreset(presetKey) {
        try {
          if (presetKey === 'custom') {
            select('#fabricDescription').html('Using custom parameter settings.');
            return;
          }
          
          let preset = FABRIC_PRESETS[presetKey];
          if (!preset) return;
          
          // Update description
          select('#fabricDescription').html(preset.properties.description);
          
          // Set parameters based on preset
          setDamping(true, preset.properties.damping);
          setStretch(true, preset.properties.stretch);
          setBending(true, preset.properties.bending);
          setShear(true, preset.properties.shear);
          setWeight(true, preset.properties.weight);
          
          // Update simulation
          setupCloth();
        } catch (error) {
          console.error("Error applying fabric preset:", error);
        }
      }
      
      /* Animation and Time-lapse Features */
      function toggleRecording() {
        try {
          recordingActive = !recordingActive;
          
          if (recordingActive) {
            // Start recording
            select('#recordBtn').html('Stop Recording');
            recordedFrames = [];
            
            // Record initial state
            recordClothState();
          } else {
            // Stop recording
            select('#recordBtn').html('Start Recording');
            select('#playBtn').removeAttribute('disabled');
            
            // Show stats about recording
            const memory = estimateMemoryUsage();
            console.log(`Recording complete. Frames: ${recordedFrames.length}, Estimated memory: ${memory.toFixed(2)} MB`);
          }
        } catch (error) {
          console.error("Error toggling recording:", error);
          showError("Error with recording system. Please try again.");
        }
      }

      function recordClothState() {
        try {
          if (!recordingActive) return;
          
          // Create compressed representation of cloth points
          let frameState = [];
          
          // Sampling frequency - record fewer points for large cloth
          // This is a key optimization to reduce memory usage
          const step = clothPoints.length > 1000 ? 3 : (clothPoints.length > 500 ? 2 : 1);
          
          // For very large cloth, sample key structural points
          const samplingStrategy = (clothPoints.length > 2000) ? "structural" : "uniform";
          
          if (samplingStrategy === "uniform") {
            // Simple uniform sampling
            for (let i = 0; i < clothPoints.length; i += step) {
              let p = clothPoints[i];
              
              if (p) {
                frameState.push({
                  index: i,
                  x: p.x,
                  y: p.y,
                  z: p.z,
                  oldx: p.oldx,
                  oldy: p.oldy,
                  oldz: p.oldz,
                  pinned: p.pinned
                });
              }
            }
          } else {
            // Structural sampling - prioritize grid points over internal details
            for (let y = 0; y < rows; y += step) {
              for (let x = 0; x < cols; x += step) {
                if (isValidGridPoint(y, x)) {
                  const i = grid[y][x];
                  let p = clothPoints[i];
                  
                  if (p) {
                    frameState.push({
                      index: i,
                      x: p.x,
                      y: p.y,
                      z: p.z,
                      oldx: p.oldx,
                      oldy: p.oldy,
                      oldz: p.oldz,
                      pinned: p.pinned
                    });
                  }
                }
              }
            }
          }
          
          recordedFrames.push(frameState);
          
          // Memory management - limit to reasonable number of frames
          // 200 frames = 10 seconds at 20fps
          const maxFrames = 200;
          if (recordedFrames.length > maxFrames) {
            // Remove oldest frame
            recordedFrames.shift();
          }
          
          // Check recording size
          if (recordedFrames.length % 50 === 0) {
            const memory = estimateMemoryUsage();
            if (memory > 50) {
              // Memory usage is too high, increase step size
              step++;
              console.log(`Memory usage high (${memory.toFixed(2)} MB). Reducing recording quality.`);
            }
          }
          
          // Schedule next recording
          setTimeout(recordClothState, 50); // 20 fps
        } catch (error) {
          console.error("Error recording state:", error);
          recordingActive = false;
          select('#recordBtn').html('Start Recording');
          showError("Recording error: " + error.message);
        }
      }

      // Estimate memory usage of recorded frames
      function estimateMemoryUsage() {
        try {
          // Each point record uses approximately 8 bytes per number (6 coordinates + index)
          // Plus object overhead
          const bytesPerPoint = 7 * 8 + 32; // 7 numbers + object overhead
          
          let totalPoints = 0;
          for (let frame of recordedFrames) {
            totalPoints += frame.length;
          }
          
          // Convert to MB
          return (totalPoints * bytesPerPoint) / (1024 * 1024);
        } catch (error) {
          console.error("Error estimating memory usage:", error);
          return 0;
        }
      }

      function togglePlayback() {
        try {
          playbackActive = !playbackActive;
          
          if (playbackActive) {
            // Start playback
            select('#playBtn').html('Stop Playback');
            select('#recordBtn').attribute('disabled', true);
            
            // Disable simulation during playback
            simulationRunning = false;
            select('#playPauseBtn').html('Play Simulation');
            
            // Reset playback position
            playbackFrame = 0;
            
            // Start playback interval
            playbackInterval = setInterval(() => {
              if (playbackFrame >= recordedFrames.length) {
                playbackFrame = 0;
              }
              
              restoreClothState(recordedFrames[playbackFrame]);
              playbackFrame++;
            }, 50); // 20 fps
            
          } else {
            // Stop playback
            select('#playBtn').html('Play Animation');
            select('#recordBtn').removeAttribute('disabled');
            
            // Clear interval
            clearInterval(playbackInterval);
            playbackInterval = null;
          }
        } catch (error) {
          console.error("Error toggling playback:", error);
          showError("Error with playback system. Please try again.");
        }
      }
      
      // Improved playback with interpolation
      function restoreClothState(frameState) {
        try {
          // Reset all point positions to their last positions first
          // This helps with points that aren't in the sparse recording
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            if (!p || p.pinned) continue;
            
            // Only reset position, not previous position
            // This creates smoother transitions
            p.x = p.oldx;
            p.y = p.oldy;
            p.z = p.oldz;
          }
          
          // Apply recorded points
          for (let i = 0; i < frameState.length; i++) {
            let state = frameState[i];
            let index = state.index;
            
            if (clothPoints[index]) {
              clothPoints[index].x = state.x;
              clothPoints[index].y = state.y;
              clothPoints[index].z = state.z;
              clothPoints[index].oldx = state.oldx;
              clothPoints[index].oldy = state.oldy;
              clothPoints[index].oldz = state.oldz;
              // Don't override pinned status
            }
          }
          
          // Interpolate missing points by running constraint satisfaction
          // This creates a more accurate reconstruction of the full cloth state
          for (let iter = 0; iter < 3; iter++) {
            smoothClothState();
          }
        } catch (error) {
          console.error("Error restoring state:", error);
        }
      }
      
      // Smooth out cloth state by averaging neighboring points (for sparse recordings)
      function smoothClothState() {
        try {
          // Only smooth horizontal/vertical neighbors in grid
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (!isValidGridPoint(y, x)) continue;
              
              let idx = grid[y][x];
              let p = clothPoints[idx];
              
              // Skip invalid or pinned points
              if (!p || p.pinned) continue;
              
              let neighbors = [];
              
              // Check left
              if (x > 0 && isValidGridPoint(y, x-1)) {
                let left = clothPoints[grid[y][x-1]];
                if (left) neighbors.push(left);
              }
              
              // Check right
              if (x < cols - 1 && isValidGridPoint(y, x+1)) {
                let right = clothPoints[grid[y][x+1]];
                if (right) neighbors.push(right);
              }
              
              // Check top
              if (y > 0 && isValidGridPoint(y-1, x)) {
                let top = clothPoints[grid[y-1][x]];
                if (top) neighbors.push(top);
              }
              
              // Check bottom
              if (y < rows - 1 && isValidGridPoint(y+1, x)) {
                let bottom = clothPoints[grid[y+1][x]];
                if (bottom) neighbors.push(bottom);
              }
              
              // Apply average of neighbors
              if (neighbors.length > 0) {
                let avgX = 0, avgY = 0, avgZ = 0;
                let avgOldX = 0, avgOldY = 0, avgOldZ = 0;
                
                for (let n of neighbors) {
                  avgX += n.x;
                  avgY += n.y;
                  avgZ += n.z;
                  avgOldX += n.oldx;
                  avgOldY += n.oldy;
                  avgOldZ += n.oldz;
                }
                
                // Blend with current value (30% neighbors, 70% current)
                let weight = 0.3;
                p.x = p.x * (1 - weight) + (avgX / neighbors.length) * weight;
                p.y = p.y * (1 - weight) + (avgY / neighbors.length) * weight;
                p.z = p.z * (1 - weight) + (avgZ / neighbors.length) * weight;
                p.oldx = p.oldx * (1 - weight) + (avgOldX / neighbors.length) * weight;
                p.oldy = p.oldy * (1 - weight) + (avgOldY / neighbors.length) * weight;
                p.oldz = p.oldz * (1 - weight) + (avgOldZ / neighbors.length) * weight;
              }
            }
          }
        } catch (error) {
          console.error("Error smoothing cloth state:", error);
        }
      }
      
      function createTimelapse() {
        try {
          // Start with a fresh cloth
          setupCloth();
          
          // Disable UI during timelapse
          select('#timelapseBtn').html('Creating Time-lapse...');
          select('#timelapseBtn').attribute('disabled', true);
          select('#recordBtn').attribute('disabled', true);
          select('#playBtn').attribute('disabled', true);
          
          // Make sure simulation is running
          simulationRunning = true;
          
          // Create overlay to display timelapse
          let overlay = createDiv();
          overlay.id('timelapseOverlay');
          overlay.parent('canvasContainer');
          overlay.style('position', 'absolute');
          overlay.style('top', '20px');
          overlay.style('right', '20px');
          overlay.style('background', 'rgba(26, 32, 44, 0.95)');
          overlay.style('padding', '15px');
          overlay.style('border-radius', '8px');
          overlay.style('color', 'white');
          overlay.html('Creating time-lapse: 0%');
          
          // Start timelapse recording
          recordTimelapse(0, 100, overlay);
        } catch (error) {
          console.error("Error creating timelapse:", error);
          showError("Error creating timelapse. Please try again.");
        }
      }
      
      function recordTimelapse(currentStep, totalSteps, overlay) {
        try {
          // Update progress
          let progress = floor((currentStep / totalSteps) * 100);
          overlay.html(`Creating time-lapse: ${progress}%`);
          
          // In a real implementation, would save canvas state
          
          // Move to next step or complete
          if (currentStep < totalSteps) {
            // Update simulation multiple times to advance state
            for (let i = 0; i < 5; i++) {
              updateCloth();
            }
            
            // Schedule next recording after a short delay
            setTimeout(() => {
              recordTimelapse(currentStep + 1, totalSteps, overlay);
            }, 50);
          } else {
            // Complete timelapse
            finishTimelapse(overlay);
          }
        } catch (error) {
          console.error("Error in timelapse recording:", error);
          finishTimelapse(overlay, true);
        }
      }
      
      function finishTimelapse(overlay, error = false) {
        try {
          // In a real implementation, would compile frames into animation
          if (error) {
            overlay.html('Time-lapse failed.<br><button id="dismissBtn">Dismiss</button>');
          } else {
            overlay.html('Time-lapse complete!<br><button id="dismissBtn">Dismiss</button>');
          }
          
          // Add dismiss button action
          select('#dismissBtn').mousePressed(() => {
            overlay.remove();
          });
          
          // Re-enable UI
          select('#timelapseBtn').html('Create Time-lapse');
          select('#timelapseBtn').removeAttribute('disabled');
          select('#recordBtn').removeAttribute('disabled');
          select('#playBtn').removeAttribute('disabled');
        } catch (error) {
          console.error("Error finishing timelapse:", error);
          // Emergency cleanup
          overlay.remove();
          select('#timelapseBtn').html('Create Time-lapse');
          select('#timelapseBtn').removeAttribute('disabled');
          select('#recordBtn').removeAttribute('disabled');
          select('#playBtn').removeAttribute('disabled');
        }
      }
      
      /* Animation presets */
      // Clear any existing animation intervals
      let activeAnimationInterval = null;

      function applyAnimationPreset(preset) {
        try {
          // Stop any existing animation
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
          
          // Reset cloth first
          setupCloth();
          
          // Make sure simulation is running
          simulationRunning = true;
          select('#playPauseBtn').html('Pause Simulation');
          
          // Apply the requested animation preset
          switch (preset) {
            case 'breeze':
              applyBreezePreset();
              break;
            case 'gust':
              applyGustPreset();
              break;
            case 'drop':
              applyDropPreset();
              break;
            case 'material':
              applyMaterialTestPreset();
              break;
            case 'gravity':
              applyGravityPreset();
              break;
            default:
              console.warn("Unknown animation preset:", preset);
          }
          
          // Reset dropdown after a delay
          setTimeout(() => {
            try {
              document.getElementById('animationPresetSelect').value = '';
            } catch (e) {
              console.error("Could not reset animation dropdown:", e);
            }
          }, 500);
        } catch (error) {
          console.error("Error applying animation preset:", error);
          showError("Error applying animation. Please try again.");
          
          // Cleanup any intervals in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyBreezePreset() {
        try {
          // Set up gentle breeze animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.98);
          setGravity(true, 0.3);
          setShadingMode("cloth");
          
          // Start with no wind
          setWind(true, 0, 0, 0);
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 200;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            // Oscillating gentle wind
            let windStrength = 0.1 * Math.sin(step * 0.1);
            setWind(true, windStrength, 0, windStrength * 0.5);
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in breeze preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyGustPreset() {
        try {
          // Set up for wind gust animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.3);
          setShadingMode("cloth");
          
          // Start with no wind
          setWind(true, 0, 0, 0);
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 150;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step > 20 && step < 40) {
              // Build up
              let ramp = map(step, 20, 40, 0, 0.8);
              setWind(true, ramp, 0, ramp * 0.3);
            } else if (step >= 40 && step < 70) {
              // Full gust
              setWind(true, 0.8, 0, 0.24);
            } else if (step >= 70 && step < 90) {
              // Fade out
              let ramp = map(step, 70, 90, 0.8, 0);
              setWind(true, ramp, 0, ramp * 0.3);
            } else {
              // No wind
              setWind(true, 0, 0, 0);
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in gust preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyDropPreset() {
        try {
          // Set up for cloth drop animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(false, 0);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animate after a short delay
          setTimeout(() => {
            // Turn on gravity after a delay
            setGravity(true, 0.4);
          }, 1000);
        } catch (error) {
          console.error("Error in drop preset:", error);
        }
      }

      function applyMaterialTestPreset() {
        try {
          // Set up for material test
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.4);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 170;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step === 10) {
              // Start with stiff material
              setStretch(true, 0.8);
              setBending(true, 1.2);
              showError("Testing stiff material");
            } else if (step === 50) {
              // Change to medium material
              setStretch(true, 1.0);
              setBending(true, 1.0);
              showError("Testing medium material");
            } else if (step === 90) {
              // Change to soft, flexible material
              setStretch(true, 1.2);
              setBending(true, 0.8);
              showError("Testing soft material");
            } else if (step === 130) {
              // Change to very stretchy material
              setStretch(true, 1.5);
              setBending(true, 0.6);
              showError("Testing stretchy material");
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in material test preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }

      function applyGravityPreset() {
        try {
          // Set up for gravity increase animation
          setSimulationMode("plane");
          setPinningMode("top");
          setDamping(true, 0.97);
          setGravity(true, 0.1);
          setWind(false, 0, 0, 0);
          setShadingMode("cloth");
          
          // Animation steps counter
          let step = 0;
          let maxSteps = 150;
          
          // Start animation interval
          activeAnimationInterval = setInterval(() => {
            step++;
            
            if (step % 20 === 0 && step <= 100) {
              // Increase gravity in steps
              let gravityValue = map(step, 0, 100, 0.1, 1.0);
              setGravity(true, gravityValue);
              showError(`Gravity: ${gravityValue.toFixed(2)}`);
            }
            
            // End animation after a while
            if (step >= maxSteps) {
              clearInterval(activeAnimationInterval);
              activeAnimationInterval = null;
            }
          }, 100);
        } catch (error) {
          console.error("Error in gravity preset:", error);
          // Cleanup in case of error
          if (activeAnimationInterval) {
            clearInterval(activeAnimationInterval);
            activeAnimationInterval = null;
          }
        }
      }
      
      /* Parameter setting helper functions */
      function setSimulationMode(mode) {
        try {
          let radio = selectAll('input[name="simulationMode_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              simulationMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting simulation mode:", error);
        }
      }
      
      function setFormMode(mode) {
        try {
          let radio = selectAll('input[name="formMode_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              formMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting form mode:", error);
        }
      }
      
      function setPinningMode(mode) {
        try {
          let radio = selectAll('input[name="pinning_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              pinningMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting pinning mode:", error);
        }
      }
      
      function setShadingMode(mode) {
        try {
          let radio = selectAll('input[name="shading_radio"]');
          for (let r of radio) {
            if (r.value() === mode) {
              r.checked(true);
              shadingMode = mode;
            }
          }
        } catch (error) {
          console.error("Error setting shading mode:", error);
        }
      }
      
      function setDamping(enabled, value) {
        try {
          setRadioParam("dampingRadioGroup_radio", enabled);
          dampingOn = enabled;
          if (enabled) {
            damping = value;
            select("#dampingVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting damping:", error);
        }
      }
      
      function setGravity(enabled, value) {
        try {
          setRadioParam("gravityRadioGroup_radio", enabled);
          gravityOn = enabled;
          if (enabled) {
            gravity = value;
            select("#gravityVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting gravity:", error);
        }
      }
      
      function setWind(enabled, x, y, z) {
        try {
          setRadioParam("windXRadioGroup_radio", enabled);
          setRadioParam("windYRadioGroup_radio", enabled);
          setRadioParam("windZRadioGroup_radio", enabled);
          windXOn = windYOn = windZOn = enabled;
          if (enabled) {
            windX = x;
            windY = y;
            windZ = z;
            select("#windXVal").html(nf(x, 1, 2));
            select("#windYVal").html(nf(y, 1, 2));
            select("#windZVal").html(nf(z, 1, 2));
            // Update sliders if needed
          }
        } catch (error) {
          console.error("Error setting wind:", error);
        }
      }
      
      function setWindBuffer(enabled, value) {
        try {
          setRadioParam("windBufRadioGroup_radio", enabled);
          windBufOn = enabled;
          if (enabled) {
            windBuffer = value;
            select("#windBufVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting wind buffer:", error);
        }
      }
      
      function setStretch(enabled, value) {
        try {
          setRadioParam("stretchRadioGroup_radio", enabled);
          stretchOn = enabled;
          if (enabled) {
            stretchFactor = value;
            select("#stretchVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting stretch:", error);
        }
      }
      
      function setShear(enabled, value) {
        try {
          setRadioParam("shearRadioGroup_radio", enabled);
          shearOn = enabled;
          if (enabled) {
            shearFactor = value;
            select("#shearVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting shear:", error);
        }
      }
      
      function setBending(enabled, value) {
        try {
          setRadioParam("bendingRadioGroup_radio", enabled);
          bendingOn = enabled;
          if (enabled) {
            bendingFactor = value;
            select("#bendingVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting bending:", error);
        }
      }
      
      function setWeight(enabled, value) {
        try {
          setRadioParam("weightRadioGroup_radio", enabled);
          weightOn = enabled;
          if (enabled) {
            weight = value;
            select("#weightVal").html(nf(value, 1, 2));
            // Update slider if needed
          }
        } catch (error) {
          console.error("Error setting weight:", error);
        }
      }
      
      function setRadioParam(radioName, enabled) {
        try {
          let radio = selectAll(`input[name="${radioName}"]`);
          for (let r of radio) {
            if (r.value() === (enabled ? "on" : "off")) {
              r.checked(true);
            }
          }
          
          // Update container visibility if needed
          let containerId = radioName.replace("_radio", "").replace("Radio", "Container");
          let container = select("#" + containerId);
          if (container) {
            container.style('display', enabled ? 'block' : 'none');
          }
        } catch (error) {
          console.error(`Error setting radio param ${radioName}:`, error);
        }
      }
      
      /* Educational overlay system */
      function setupEducationalOverlays() {
        try {
          // Create overlay container
          let overlayContainer = createDiv();
          overlayContainer.id('overlayContainer');
          overlayContainer.parent('canvasContainer');
          
          // Create explanation panels for different parameters
          createExplanationPanel('Damping', 
            `<h3>Damping</h3>
             <p>Damping controls how quickly the cloth loses energy. It simulates air resistance and internal friction in the fabric.</p>
             <p class="formula">velocity *= damping</p>
             <p>Higher damping (closer to 0) causes the cloth to settle quickly. Lower damping (closer to 1) allows the cloth to oscillate for longer.</p>
             <p>Real-world equivalent: Silk has lower damping than wool.</p>`
          );
          
          createExplanationPanel('Constraints', 
            `<h3>Cloth Constraints</h3>
             <p>Cloth is modeled using three types of constraints:</p>
             <ul>
               <li><strong>Structural</strong> (green lines): Maintain distance between adjacent points</li>
               <li><strong>Shear</strong> (yellow lines): Resist diagonal distortion</li>
               <li><strong>Bending</strong> (blue lines): Resist folding</li>
             </ul>
             <p>Each constraint tries to maintain its rest length by applying corrective forces.</p>
             <p class="formula">position += (current_length - rest_length) * correction_factor</p>`
          );
          
          createExplanationPanel('Integration', 
            `<h3>Verlet Integration</h3>
             <p>This simulation uses Verlet integration, a method that:</p>
             <ul>
               <li>Stores position and previous position instead of position and velocity</li>
               <li>Implicitly calculates velocity as the difference between current and previous positions</li>
             </ul>
             <p>The integration steps are:</p>
             <ol>
               <li>Calculate velocity: v = position - old_position</li>
               <li>Apply damping: v *= damping</li>
               <li>Save current position: old_position = position</li>
               <li>Apply forces and update: position += v + forces</li>
               <li>Apply constraints multiple times</li>
             </ol>
             <p class="formula">x' = x + (x - x_prev) * damping + forces</p>
             <p>Verlet integration provides good stability for cloth simulation.</p>`
          );
          
          createExplanationPanel('Stretch', 
            `<h3>Stretch Resistance</h3>
             <p>Stretch factor controls how much the cloth can extend or compress along its primary threads.</p>
             <p>Higher values make the cloth more rigid, while lower values allow it to stretch more easily.</p>
             <p>The stretch constraint applies to adjacent points in the grid and tries to maintain its rest length.</p>
             <p>Real-world equivalent: Elastic fabrics have lower stretch resistance than woven cotton.</p>`
          );
          
          createExplanationPanel('Shear', 
            `<h3>Shear Resistance</h3>
             <p>Shear factor controls how much the cloth can deform diagonally.</p>
             <p>Higher values resist diagonal deformation, creating a more rigid fabric behavior.</p>
             <p>The shear constraint applies to diagonal connections in the grid cells.</p>
             <p>Real-world equivalent: Woven fabrics typically have higher shear resistance than knits.</p>`
          );
          
          createExplanationPanel('Bending', 
            `<h3>Bending Resistance</h3>
             <p>Bending factor controls how much the cloth resists folding.</p>
             <p>Higher values create a stiffer fabric that doesn't fold easily, while lower values allow for soft creases.</p>
             <p>The bending constraint connects alternating points in the grid.</p>
             <p>Real-world equivalent: Paper has high bending resistance, while silk has low resistance.</p>`
          );
          
          createExplanationPanel('Iterations', 
            `<h3>Constraint Iterations</h3>
             <p>Iterations determine how many times constraints are applied per frame.</p>
             <p>Higher values create a more stable but computationally expensive simulation.</p>
             <p>When iterations are low, constraints might not be fully satisfied, leading to stretching.</p>
             <p>Think of this as how "perfectly" the fabric maintains its properties.</p>`
          );
          
          createExplanationPanel('Wind', 
            `<h3>Wind Forces</h3>
             <p>Wind creates external forces that push the cloth in different directions.</p>
             <p>X, Y, and Z values control the wind direction and strength along each axis.</p>
             <p>Wind buffer acts as a multiplier for the overall wind effect.</p>
             <p>Wind varies over time with a sinusoidal pattern to create natural-looking movement.</p>`
          );
          
          createExplanationPanel('Gravity', 
            `<h3>Gravity Force</h3>
             <p>Gravity controls the downward acceleration applied to the cloth.</p>
             <p>Higher values create a stronger gravitational pull.</p>
             <p>When combined with weight, it determines how fast the cloth falls and how much it stretches.</p>
             <p>Gravity primarily affects the Y-axis in this simulation.</p>`
          );
          
          createExplanationPanel('Stress', 
            `<h3>Stress Visualization</h3>
             <p>The stress visualization shows areas under tension (red) or compression (blue).</p>
             <p>It works by comparing the current area of each cloth cell with its rest area.</p>
             <p>Areas that are stretched appear red, while compressed areas appear blue.</p>
             <p>This visualization helps understand how forces distribute through the cloth.</p>`
          );
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(overlayContainer);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(toggleOverlay);
        } catch (error) {
          console.error("Error setting up educational overlays:", error);
        }
      }
      
      function createExplanationPanel(topic, htmlContent) {
        try {
          if (!window.explanationPanels) {
            window.explanationPanels = {};
          }
          
          let panel = createDiv();
          panel.parent('overlayContainer');
          panel.id('explanation_' + topic.toLowerCase().replace(' ', '_'));
          panel.html(htmlContent);
          panel.style('display', 'none');
          
          window.explanationPanels[topic] = panel;
        } catch (error) {
          console.error(`Error creating explanation panel for ${topic}:`, error);
        }
      }
      
      function showExplanation(topic) {
        try {
          // Hide all explanations
          for (let t in window.explanationPanels) {
            window.explanationPanels[t].style('display', 'none');
          }
          
          // Show requested topic
          if (window.explanationPanels && window.explanationPanels[topic]) {
            window.explanationPanels[topic].style('display', 'block');
            select('#overlayContainer').style('display', 'block');
          }
        } catch (error) {
          console.error(`Error showing explanation for ${topic}:`, error);
        }
      }
      
      function toggleOverlay() {
        try {
          let overlay = select('#overlayContainer');
          let isVisible = overlay.style('display') === 'block';
          overlay.style('display', isVisible ? 'none' : 'block');
          select('#showExplanationsBtn').html(isVisible ? 'Show Explanations' : 'Hide Explanations');
          
          // If showing overlay, display the first explanation
          if (!isVisible) {
            let firstTopic = Object.keys(window.explanationPanels)[0];
            showExplanation(firstTopic);
          }
        } catch (error) {
          console.error("Error toggling overlay:", error);
        }
      }
      
      // Add hover triggers to parameter headers
      function addExplanationTriggers() {
        try {
          // Add info icons next to parameter headers
          let params = selectAll('.paramHeader');
          for (let p of params) {
            let paramName = p.html().split(':')[0].trim();
            
            // Only add for parameters we have explanations for
            if (window.explanationPanels && window.explanationPanels[paramName]) {
              let infoIcon = createSpan('ⓘ');
              infoIcon.parent(p);
              infoIcon.class('infoIcon');
              infoIcon.mouseOver(() => {
                showExplanation(paramName);
              });
            }
          }
          
          // Add general explanation triggers
          let structureTrigger = createSpan('ⓘ');
          structureTrigger.position(10, 10);
          structureTrigger.parent(select("#shadingRadioGroup").parent());
          structureTrigger.class('infoIcon');
          structureTrigger.mouseOver(() => {
            showExplanation('Constraints');
          });
          
          let stressTrigger = createSpan('ⓘ');
          stressTrigger.position(10, 10);
          stressTrigger.parent(select("#shadingRadioGroup").parent());
          stressTrigger.class('infoIcon');
          stressTrigger.mouseOver(() => {
            showExplanation('Stress');
          });
        } catch (error) {
          console.error("Error adding explanation triggers:", error);
        }
      }
      
      /* Physics metrics visualization */
      function setupPhysicsMetrics() {
        try {
          // Create metrics panel (hidden by default)
          let metricsPanel = createDiv();
          metricsPanel.id('physicsMetrics');
          metricsPanel.style('display', 'none');
          metricsPanel.parent('canvasContainer');
          
          // Add metrics visualization elements
          let energyGraph = createDiv();
          energyGraph.parent(metricsPanel);
          energyGraph.id('energyGraph');
          energyGraph.html('<h3>Energy Analysis</h3>');
          
          let stressHeatmap = createDiv();
          stressHeatmap.parent(metricsPanel);
          stressHeatmap.id('stressHeatmap');
          stressHeatmap.html('<h3>Stress Distribution</h3>');
          
          let forceVectors = createDiv();
          forceVectors.parent(metricsPanel);
          forceVectors.id('forceVectors');
          forceVectors.html('<h3>Force Analysis</h3>');
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(metricsPanel);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(togglePhysicsPanel);
        } catch (error) {
          console.error("Error setting up physics metrics:", error);
        }
      }
      
      function togglePhysicsPanel() {
        try {
          let panel = select('#physicsMetrics');
          if (!panel) {
            setupPhysicsMetrics();
            panel = select('#physicsMetrics');
          }
          
          let isVisible = panel.style('display') === 'block';
          panel.style('display', isVisible ? 'none' : 'block');
          select('#showPhysicsBtn').html(isVisible ? 'Show Physics Metrics' : 'Hide Physics Metrics');
        } catch (error) {
          console.error("Error toggling physics panel:", error);
        }
      }
      
      function updatePhysicsMetrics() {
        try {
          let panel = select('#physicsMetrics');
          if (!panel || panel.style('display') !== 'block') return;
          
          // Calculate total kinetic energy
          let totalKE = 0;
          let sampleCount = 0;
          
          // Sample a subset of points for better performance
          const step = Math.max(1, Math.floor(clothPoints.length / 100));
          
          for (let i = 0; i < clothPoints.length; i += step) {
            let p = clothPoints[i];
            
            if (!p || p.pinned) continue;
            
            let vx = p.x - p.oldx;
            let vy = p.y - p.oldy;
            let vz = p.z - p.oldz;
            let v2 = vx*vx + vy*vy + vz*vz;
            totalKE += v2;
            sampleCount++;
          }
          
          // Scale by sample ratio
          if (sampleCount > 0) {
            totalKE = totalKE * (clothPoints.length / sampleCount);
          }
          
          // Calculate tension/compression energy from constraints
          let strainEnergy = 0;
          sampleCount = 0;
          const constraintStep = Math.max(1, Math.floor(clothConstraints.length / 100));
          
          for (let i = 0; i < clothConstraints.length; i += constraintStep) {
            if (i >= clothConstraints.length) continue;
            let c = clothConstraints[i];
            if (!c) continue;
            
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            if (!p1 || !p2) continue;
            
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dz = p2.z - p1.z;
            let d = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (d > 0 && c.length > 0) {
              let strain = Math.abs(d - c.length) / c.length;
              strainEnergy += strain * strain;
              sampleCount++;
            }
          }
          
          // Scale by sample ratio
          if (sampleCount > 0) {
            strainEnergy = strainEnergy * (clothConstraints.length / sampleCount);
          }
          
          // Update energy info
          let energyInfo = `<h3>Energy Analysis</h3>
                           <p>Kinetic Energy: ${nf(totalKE, 1, 2)}</p>
                           <p>Strain Energy: ${nf(strainEnergy, 1, 2)}</p>
                           <p>Total Energy: ${nf(totalKE + strainEnergy, 1, 2)}</p>
                           <p>Simulation FPS: ${nf(frameRate, 1, 1)}</p>`;
          
          select('#energyGraph').html(energyInfo);
          
          // Update stress info - lower sampling rate for performance
          let maxStress = 0;
          let avgStress = 0;
          let stressCount = 0;
          
          // Compute stress from cell areas
          const rowStep = Math.max(1, Math.floor(rows / 5));
          const colStep = Math.max(1, Math.floor(cols / 5));
          
          for (let y = 0; y < rows - 1; y += rowStep) {
            for (let x = 0; x < cols - 1; x += colStep) {
              // Check if we have valid indices
              if (!isValidGridPoint(y, x) || !isValidGridPoint(y, x+1) || 
                  !isValidGridPoint(y+1, x) || !isValidGridPoint(y+1, x+1)) {
                continue;
              }
              
              let idxA = grid[y][x];
              let idxB = grid[y][x+1];
              let idxC = grid[y+1][x];
              let idxD = grid[y+1][x+1];
              
              // Check for valid points
              if (!clothPoints[idxA] || !clothPoints[idxB] || 
                  !clothPoints[idxC] || !clothPoints[idxD]) {
                continue;
              }
              
              // Check if we have valid rest area data
              if (!cellRestArea[y] || cellRestArea[y][x] === undefined) {
                continue;
              }
              
              let A = clothPoints[idxA];
              let B = clothPoints[idxB];
              let C = clothPoints[idxC];
              let D = clothPoints[idxD];
              
              let currArea = computeQuadArea(A, B, C, D);
              let restArea = cellRestArea[y][x];
              
              if (restArea > 0) {
                let diff = Math.abs(currArea - restArea) / restArea;
                maxStress = Math.max(maxStress, diff);
                avgStress += diff;
                stressCount++;
              }
            }
          }
          
          if (stressCount > 0) {
            avgStress = avgStress / stressCount;
          }
          
          let stressInfo = `<h3>Stress Analysis</h3>
                           <p>Maximum Stress: ${nf(maxStress * 100, 1, 2)}%</p>
                           <p>Average Stress: ${nf(avgStress * 100, 1, 2)}%</p>`;
          
          select('#stressHeatmap').html(stressInfo);
          
          // Update force info
          let gravityForce = gravityOn ? (gravity * weight) : 0;
          let windForce = Math.sqrt(windX*windX + windY*windY + windZ*windZ);
          windForce = (windXOn || windYOn || windZOn) ? windForce : 0;
          
          let forceInfo = `<h3>Force Analysis</h3>
                          <p>Gravity Force: ${nf(gravityForce, 1, 2)}</p>
                          <p>Wind Force: ${nf(windForce, 1, 2)}</p>
                          <p>Cloth Points: ${clothPoints.length}</p>
                          <p>Constraints: ${clothConstraints.length}</p>`;
          
          select('#forceVectors').html(forceInfo);
        } catch (error) {
          console.error("Error updating physics metrics:", error);
        }
      }
      
      /* Comparison view between real fabric and simulation */
      function toggleComparisonView() {
        try {
          // Create comparison overlay if it doesn't exist
          if (!select('#comparisonOverlay')) {
            createComparisonOverlay();
          }
          
          let overlay = select('#comparisonOverlay');
          let isVisible = overlay.style('display') === 'block';
          overlay.style('display', isVisible ? 'none' : 'block');
          select('#showComparisonBtn').html(isVisible ? 'Show Real vs. Simulated' : 'Hide Comparison');
        } catch (error) {
          console.error("Error toggling comparison view:", error);
        }
      }
      
      function createComparisonOverlay() {
        try {
          // Create comparison overlay
          let comparisonOverlay = createDiv();
          comparisonOverlay.id('comparisonOverlay');
          comparisonOverlay.parent('canvasContainer');
          
          // Add title
          let comparisonTitle = createElement('h3', 'Real vs. Simulated Cloth');
          comparisonTitle.parent(comparisonOverlay);
          
          // Add comparison content
          let comparisonContent = createDiv();
          comparisonContent.parent(comparisonOverlay);
          comparisonContent.id('comparisonContent');
          
          let html = '';
          html += '<div style="margin-bottom: 15px;">';
          html += '<p>Real fabrics behave differently than simulated cloth due to:</p>';
          html += '<ul>';
          html += '<li>Complex fiber structures that our simulation approximates</li>';
          html += '<li>Varying material properties throughout the fabric</li>';
          html += '<li>Different behavior in warp vs. weft directions</li>';
          html += '<li>Complex interactions between fibers</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Silk</h4>';
          html += '<p>Real silk drapes fluidly with a lustrous appearance. Our simulation approximates this with:</p>';
          html += '<ul>';
          html += '<li>Low bending resistance (0.7)</li>';
          html += '<li>High damping (0.99)</li>';
          html += '<li>Low weight (0.7)</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Denim</h4>';
          html += '<p>Real denim is stiff and heavy. Our simulation models this with:</p>';
          html += '<ul>';
          html += '<li>High bending resistance (1.1)</li>';
          html += '<li>Lower damping (0.95)</li>';
          html += '<li>Higher weight (1.2)</li>';
          html += '</ul>';
          html += '</div>';
          
          html += '<div style="margin-bottom: 15px;">';
          html += '<h4>Experiment</h4>';
          html += '<p>Try draping different fabric presets over the sphere to compare their behavior!</p>';
          html += '</div>';
          
          comparisonContent.html(html);
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(comparisonOverlay);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(() => {
            comparisonOverlay.style('display', 'none');
            select('#showComparisonBtn').html('Show Real vs. Simulated');
          });
        } catch (error) {
          console.error("Error creating comparison overlay:", error);
        }
      }
      
      /* Guided learning system */
      function setupGuidedLearning() {
        try {
          // Create learning panel
          let learningPanel = createDiv();
          learningPanel.id('learningPanel');
          learningPanel.parent('canvasContainer');
          learningPanel.style('display', 'none');
          
          // Scenario selector
          let scenarioSelect = createSelect();
          scenarioSelect.parent(learningPanel);
          scenarioSelect.id('scenarioSelect');
          for (let i = 0; i < LEARNING_SCENARIOS.length; i++) {
            scenarioSelect.option(LEARNING_SCENARIOS[i].title, i);
          }
          scenarioSelect.changed(scenarioChanged);
          
          // Title and content divs
          let stepTitle = createDiv();
          stepTitle.parent(learningPanel);
          stepTitle.id('stepTitle');
          
          let stepInstructions = createDiv();
          stepInstructions.parent(learningPanel);
          stepInstructions.id('stepInstructions');
          
          let stepExplanation = createDiv();
          stepExplanation.parent(learningPanel);
          stepExplanation.id('stepExplanation');
          
          // Navigation buttons
          let btnContainer = createDiv();
          btnContainer.parent(learningPanel);
          btnContainer.style('display', 'flex');
          btnContainer.style('justify-content', 'space-between');
          btnContainer.style('margin-top', '15px');
          
          let prevBtn = createButton('« Previous');
          prevBtn.parent(btnContainer);
          prevBtn.id('prevStepBtn');
          prevBtn.style('width', '48%');
          prevBtn.mousePressed(previousStep);
          
          let nextBtn = createButton('Next »');
          nextBtn.parent(btnContainer);
          nextBtn.id('nextStepBtn');
          nextBtn.style('width', '48%');
          nextBtn.mousePressed(nextStep);
          
          // Add close button
          let closeBtn = createButton('×');
          closeBtn.parent(learningPanel);
          closeBtn.style('position', 'absolute');
          closeBtn.style('top', '10px');
          closeBtn.style('right', '10px');
          closeBtn.style('background', 'transparent');
          closeBtn.style('border', 'none');
          closeBtn.style('color', 'white');
          closeBtn.style('font-size', '20px');
          closeBtn.style('width', 'auto');
          closeBtn.mousePressed(toggleGuidedLearning);
        } catch (error) {
          console.error("Error setting up guided learning:", error);
        }
      }
      
      function toggleGuidedLearning() {
        try {
          guidedLearningActive = !guidedLearningActive;
          
          if (!select('#learningPanel')) {
            setupGuidedLearning();
          }
          
          select('#learningPanel').style('display', guidedLearningActive ? 'block' : 'none');
          select('#startLearningBtn').html(guidedLearningActive ? 'End Guided Learning' : 'Start Guided Learning');
          
          if (guidedLearningActive) {
            currentStep = 0;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error toggling guided learning:", error);
        }
      }
      
      function scenarioChanged() {
        try {
          if (guidedLearningActive) {
            currentStep = 0;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error changing scenario:", error);
        }
      }
      
      function nextStep() {
        try {
          let scenarioIndex = select('#scenarioSelect').value();
          let scenario = LEARNING_SCENARIOS[scenarioIndex];
          
          if (currentStep < scenario.steps.length - 1) {
            currentStep++;
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error going to next step:", error);
        }
      }
      
      function previousStep() {
        try {
          if (currentStep > 0) {
            currentStep--;
            let scenarioIndex = select('#scenarioSelect').value();
            updateLearningPanel(scenarioIndex, currentStep);
          }
        } catch (error) {
          console.error("Error going to previous step:", error);
        }
      }
      
      function updateLearningPanel(scenarioIndex, stepIndex) {
        try {
          let scenario = LEARNING_SCENARIOS[scenarioIndex];
          let step = scenario.steps[stepIndex];
          
          select('#stepTitle').html('<h3>' + step.title + '</h3>');
          select('#stepInstructions').html('<p>' + step.instructions + '</p>');
          select('#stepExplanation').html('<div class="paramDesc">' + step.explanation + '</div>');
          
          // Update button states
          select('#prevStepBtn').attribute('disabled', stepIndex === 0 ? true : null);
          select('#nextStepBtn').attribute('disabled', stepIndex === scenario.steps.length - 1 ? true : null);
          
          // Apply setup for this step
          if (step.setup) {
            try {
              step.setup();
            } catch (error) {
              console.error("Error in guided learning step setup:", error);
              showError("Error running learning step. Please try another step.");
            }
          }
        } catch (error) {
          console.error("Error updating learning panel:", error);
        }
      }
      
      /* EVENT LISTENERS */
      // Window load event
      window.addEventListener('load', function() {
        try {
          // Handle loading screen
          setTimeout(function() {
            select('#loadingOverlay').style('display', 'none');
            
            // Check for WebGL support
            const canvas = document.getElementById('defaultCanvas0');
            if (!canvas) {
              showError("Error: Canvas not initialized. Please try refreshing the page or using a different browser.");
            }
          }, 2000);
          
          // Auto-detect device capabilities
          if (windowWidth <= 768 || windowHeight <= 500) {
            // Mobile device - use lower resolution
            setSimulationQuality("low");
          } else {
            // Check if we have GPU acceleration
            const testCanvas = document.createElement('canvas');
            const testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
            
            if (!testContext || testContext.getSupportedExtensions().length < 10) {
              // Limited WebGL support - use medium quality
              setSimulationQuality("medium");
            }
          }
        } catch (error) {
          console.error("Error in window load handler:", error);
        }
      });
      
      // Performance monitoring toggle
      window.addEventListener('keydown', function(e) {
        if (e.key === 'p' || e.key === 'P') {
          showPerformanceMetrics = !showPerformanceMetrics;
          select('#performanceIndicator').style('display', showPerformanceMetrics ? 'block' : 'none');
        }
      });
    </script>
  </body>
</html>
